---
title: Event Loop
description: How the JavaScript event loop processes macro tasks and microtasks, and why execution order matters in async code.
---

## Overview

JavaScript is single-threaded — it can only do one thing at a time. Yet it handles network requests, timers, and user interactions without freezing. The **event loop** is the mechanism that makes this possible.

At the heart of it: the event loop continuously checks whether the call stack is empty, and if so, picks the next task to run. But not all tasks are equal. The event loop distinguishes between **macrotasks** (also called tasks) and **microtasks**, and processes them in a specific, deterministic order.

Understanding this order is what separates developers who "guess" async behavior from those who can reason about it precisely.

---

## How It Works

### The Call Stack

When you call a function, it gets pushed onto the call stack. When it returns, it's popped off. Synchronous code runs top to bottom, fully, before anything async gets a chance.

### Two Task Queues

After the call stack is empty, the event loop doesn't just grab the next available callback blindly. It follows a priority order:

1. **Microtask queue** — Drained _completely_ before the next macrotask runs. Includes:
   - `Promise` callbacks (`.then`, `.catch`, `.finally`)
   - `queueMicrotask()`
   - `MutationObserver` callbacks

2. **Macrotask queue** (task queue) — One task is picked per event loop iteration. Includes:
   - `setTimeout` / `setInterval` callbacks
   - `setImmediate` (Node.js)
   - I/O callbacks
   - UI rendering (browser)

The cycle looks like this:

```
[Call Stack empties]
      ↓
[Drain ALL microtasks]
      ↓
[Run ONE macrotask]
      ↓
[Drain ALL microtasks again]
      ↓
[Run ONE macrotask]
      ↓ ...
```

<Callout type="info">
  Microtasks spawned *by* microtasks are also processed before the next
  macrotask. A microtask queue that keeps adding to itself will starve
  macrotasks indefinitely.
</Callout>

---

## Code Example

### Predicting Execution Order

```ts
console.log("1 - synchronous start");

setTimeout(() => {
  console.log("5 - macrotask (setTimeout)");
}, 0);

Promise.resolve()
  .then(() => {
    console.log("3 - microtask (first .then)");
  })
  .then(() => {
    console.log(
      "4 - microtask (chained .then, queued after previous resolves)",
    );
  });

console.log("2 - synchronous end");

// Output order:
// 1 - synchronous start
// 2 - synchronous end
// 3 - microtask (first .then)
// 4 - microtask (chained .then, queued after previous resolves)
// 5 - macrotask (setTimeout)
```

Even though `setTimeout` is set to `0ms`, the Promise callbacks always run first — the microtask queue is fully drained before any macrotask executes.

---

### Microtask Starvation (What Not to Do)

```ts
// WARNING: This will starve the macrotask queue — setTimeout never fires
function infiniteMicrotasks() {
  Promise.resolve().then(infiniteMicrotasks); // schedules itself as a microtask forever
}

setTimeout(() => {
  console.log("This will never print");
}, 0);

infiniteMicrotasks();
```

<Callout type="warn">
  Never create recursive microtask loops. Since the microtask queue must fully
  drain before the next macrotask, an infinitely growing microtask queue will
  freeze all timer callbacks, I/O, and rendering.
</Callout>

---

### Real Async/Await Mapping

`async/await` is syntactic sugar over Promises, so `await` resumes execution as a microtask.

```ts
async function fetchUserData(userId: string): Promise<void> {
  console.log("A - before await"); // synchronous

  const user = await getUser(userId); // suspends here; resumes as microtask

  console.log("C - after await, got user:", user.name); // microtask
}

console.log("before call");
fetchUserData("user_42");
console.log("B - after call, before await resolves"); // still synchronous

// Output:
// before call
// A - before await
// B - after call, before await resolves
// C - after await, got user: ...
```

---

## Real-World Use Case

In a Node.js API server, you might process a database query and then immediately update a cache:

```ts
import { getProductById } from "./db.js";
import { cache } from "./cache.js";

async function handleProductRequest(productId: string) {
  // This await suspends and resumes as a microtask when the DB responds
  const product = await getProductById(productId);

  // This runs in the same microtask "tick" continuation — no macrotask gap
  // Ensures the cache update happens before any other macrotask can interleave
  cache.set(productId, product);

  return product;
}
```

Knowing that the cache update happens synchronously _after_ the await (as a microtask continuation, not a new macrotask) means you can reason confidently about race conditions.

---

## Common Mistakes / Gotchas

**1. Assuming `setTimeout(fn, 0)` runs "immediately after" the current code.**
It runs after _all_ microtasks clear. If your Promise chain is long, `setTimeout` waits for all of it.

**2. Confusing `process.nextTick` (Node.js) with microtasks.**
In Node.js, `process.nextTick` callbacks run _before_ the Promise microtask queue in each iteration — it has even higher priority than Promises. This catches many developers off guard.

```ts
process.nextTick(() => console.log("nextTick"));
Promise.resolve().then(() => console.log("promise microtask"));

// Output:
// nextTick
// promise microtask
```

**3. Expecting UI to update between awaited Promises.**
In the browser, rendering is a macrotask. If you chain multiple `await`s in a loop without yielding to the macrotask queue, the UI won't repaint until the entire async function completes.

```ts
// UI will not update between iterations — rendering is blocked until loop ends
for (const item of largeList) {
  await processItem(item); // each continuation is a microtask, not a render frame
}

// Fix: yield to the macrotask queue to allow renders
for (const item of largeList) {
  await new Promise((resolve) => setTimeout(resolve, 0)); // allows a render frame
  await processItem(item);
}
```

**4. Assuming all environments treat the queues identically.**
The WHATWG spec governs browsers; Node.js has its own event loop (libuv-based) with additional phases (`timers`, `poll`, `check`). `setImmediate` is Node-only and runs in the `check` phase — after I/O callbacks but before `setTimeout` in some cases.

---

## Summary

The JavaScript event loop processes tasks in a strict priority order: synchronous code first, then all pending microtasks (Promises, `queueMicrotask`), then one macrotask (`setTimeout`, I/O), then microtasks again, and so on. Microtasks always fully drain before the next macrotask runs, which is why Promise callbacks execute before `setTimeout(fn, 0)`. In Node.js, `process.nextTick` sits above even the Promise microtask queue. Misunderstanding this order leads to subtle bugs in async sequencing, cache coherence, and UI rendering. Mastering the event loop means you can predict and control execution order precisely, not just hope it works out.
