---
title: Overview
description: The JavaScript engine and async execution model that sits beneath all your application code — event loop, task scheduling, and async coordination patterns.
---

## JavaScript Runtime & Async

JavaScript is single-threaded, but it handles concurrency through an event-driven model that most developers use without fully understanding. This section covers the runtime internals that govern when your code runs, what blocks it, and how async operations coordinate without threads.

Start here before reading anything else — the event loop underlies every rendering decision, scheduling problem, and async bug you will encounter in the sections that follow.

## What's covered

**Event Loop, Macrotasks & Microtasks** — The execution model that powers all JavaScript async behavior. Why microtasks (Promises, `queueMicrotask`) always run before the next macrotask (setTimeout, I/O), and what this means for rendering and interaction timing.

**Task Starvation & Scheduler Priorities** — How deeply nested microtasks can starve the render loop, and how the browser's scheduler (and React's own scheduler) assign priority to different types of work.

**Promise Combinators & Error Propagation** — `Promise.all`, `Promise.allSettled`, `Promise.race`, and `Promise.any` — when each is appropriate and how unhandled rejections propagate through async chains.

**AbortController & Streaming Fetch** — Cancelling in-flight requests with `AbortController`, and reading streaming responses with `ReadableStream` — the foundation of streaming SSR on the client.
