---
title: Selective Hydration
description: How React 18 hydrates parts of the UI independently, enabling interactivity before the entire component tree is fully loaded.
---

## Overview

Hydration is the process where React attaches event listeners and internal state to server-rendered HTML, making it interactive. Traditionally, hydration was **all-or-nothing**: React had to download, parse, and hydrate the entire component tree before any part of the page became interactive.

**Selective hydration** — introduced in React 18 — breaks this constraint. React can now hydrate individual subtrees independently and in priority order, meaning a user can interact with one part of the page while other parts are still loading or hydrating.

This matters because large pages with heavy components can block interactivity for seconds. Selective hydration removes that bottleneck.

---

## How It Works

React 18's concurrent architecture lets it pause, resume, and prioritize work. When combined with `<Suspense>` boundaries, each boundary becomes a **hydration unit** — an isolated chunk React can hydrate independently.

Here's the sequence:

1. The server streams HTML to the browser. Components wrapped in `<Suspense>` can emit their HTML later (via Streaming SSR) or emit a fallback first.
2. React begins hydrating the page as soon as it receives the initial HTML — it doesn't wait for the full document.
3. If a user interacts with a not-yet-hydrated region (e.g., clicks a button), React **prioritizes that subtree**, hydrating it immediately before others.
4. Multiple `<Suspense>` boundaries hydrate **concurrently**, not sequentially.

Think of it like a concert venue opening doors section by section. People at the front can get seated and enjoy the show while the back sections are still filling in — instead of everyone waiting outside until every seat is ready.

<Callout type="info">
  Selective hydration only activates when you use `<Suspense>` boundaries. Without them, React falls back to standard full-tree hydration.
</Callout>

---

## Code Examples

### Basic Setup — Wrapping Lazy Components in Suspense

```tsx
// app/page.tsx (Next.js App Router — Server Component by default)
import { Suspense } from "react";
import ProductList from "@/components/ProductList";
import ReviewsSidebar from "@/components/ReviewsSidebar";
import HeavyAnalyticsWidget from "@/components/HeavyAnalyticsWidget";

export default function StorePage() {
  return (
    <main>
      {/* Hydrates immediately — critical content */}
      <ProductList />

      {/* Each Suspense boundary is an independent hydration unit */}
      <Suspense fallback={<p>Loading reviews…</p>}>
        <ReviewsSidebar />
      </Suspense>

      <Suspense fallback={<p>Loading analytics…</p>}>
        {/* This heavy component won't block ProductList or ReviewsSidebar */}
        <HeavyAnalyticsWidget />
      </Suspense>
    </main>
  );
}
```

### Client Component Inside a Suspense Boundary

```tsx
// components/ReviewsSidebar.tsx
"use client"; // Needs interactivity — toggle, vote buttons, etc.

import { useState } from "react";

type Review = {
  id: string;
  author: string;
  body: string;
  rating: number;
};

type Props = {
  reviews: Review[];
};

export default function ReviewsSidebar({ reviews }: Props) {
  const [expanded, setExpanded] = useState<string | null>(null);

  return (
    <aside>
      {reviews.map((review) => (
        <div key={review.id}>
          <button
            onClick={() =>
              setExpanded(review.id === expanded ? null : review.id)
            }
          >
            {review.author} — {"★".repeat(review.rating)}
          </button>

          {/* Only renders the body when expanded */}
          {expanded === review.id && <p>{review.body}</p>}
        </div>
      ))}
    </aside>
  );
}
```

```tsx
// app/product/[id]/page.tsx — Fetches and passes data to the sidebar
import { Suspense } from "react";
import ReviewsSidebar from "@/components/ReviewsSidebar";
import { getReviews } from "@/lib/api";

export default async function ProductPage({
  params,
}: {
  params: { id: string };
}) {
  // This fetch happens on the server — no client waterfall
  const reviews = await getReviews(params.id);

  return (
    <section>
      <h1>Product Details</h1>

      <Suspense fallback={<div>Loading reviews…</div>}>
        {/* ReviewsSidebar hydrates independently */}
        <ReviewsSidebar reviews={reviews} />
      </Suspense>
    </section>
  );
}
```

### Simulating User-Prioritized Hydration

React handles priority automatically — no code needed from you. If a user clicks on a `<Suspense>`-wrapped component that hasn't hydrated yet, React will synchronously hydrate just that boundary first.

```tsx
// app/dashboard/page.tsx
import { Suspense } from "react";
import NotificationsPanel from "@/components/NotificationsPanel";
import ActivityFeed from "@/components/ActivityFeed";

export default function Dashboard() {
  return (
    <div className="dashboard-grid">
      {/*
        If the user clicks the notifications bell before this hydrates,
        React will prioritize this boundary over ActivityFeed automatically.
      */}
      <Suspense fallback={<NotificationsSkeleton />}>
        <NotificationsPanel />
      </Suspense>

      <Suspense fallback={<FeedSkeleton />}>
        <ActivityFeed />
      </Suspense>
    </div>
  );
}
```

---

## Real-World Use Case

Consider a **news website** with a hero article, a comments section, and a live ticker widget.

- The hero article should be readable immediately — no Suspense needed, it hydrates first.
- The comments section is heavy (hundreds of items, vote buttons, reply forms). Wrapping it in `<Suspense>` means readers can scroll the article while comments hydrate in the background.
- The live ticker relies on a WebSocket and loads slowly. Without selective hydration, it would delay the entire page from becoming interactive. Wrapped in its own `<Suspense>`, it hydrates last without affecting anything else.

Users perceive the page as fast and interactive even though not everything is ready.

---

## Common Mistakes / Gotchas

**1. Forgetting `'use client'` on interactive components**

Selective hydration only applies to client components (those with event handlers, state, etc.). If you wrap a Server Component in `<Suspense>`, React renders it correctly but there's nothing to hydrate — it's already static HTML. Make sure components that need interactivity are marked `'use client'`.

**2. Nesting Suspense boundaries too deeply without intent**

Deeply nested boundaries can make hydration behavior hard to reason about. Place boundaries at **meaningful UI boundaries** — sidebars, modals, comment threads — not around every individual component.

<Callout type="warn">
  Wrapping tiny leaf components in `<Suspense>` adds overhead without benefit. Reserve boundaries for genuinely independent, potentially-slow subtrees.
</Callout>

**3. Assuming hydration order is guaranteed**

React hydrates boundaries based on priority (user interaction) and readiness (data available), not top-to-bottom DOM order. Don't write logic that depends on one boundary being hydrated before another.

**4. Using selective hydration as a substitute for code splitting**

Selective hydration improves the order and isolation of hydration, but it doesn't reduce JavaScript bundle size on its own. Pair it with `next/dynamic` or `React.lazy` for actual bundle splitting if components are large.

```tsx
// Combine selective hydration with lazy loading for maximum effect
import dynamic from "next/dynamic";
import { Suspense } from "react";

// Bundle-split AND independently hydrated
const HeavyChart = dynamic(() => import("@/components/HeavyChart"));

export default function ReportPage() {
  return (
    <Suspense fallback={<ChartSkeleton />}>
      <HeavyChart />
    </Suspense>
  );
}
```

---

## Summary

Selective hydration is React 18's mechanism for hydrating `<Suspense>`-wrapped subtrees independently and in priority order, rather than blocking on the entire component tree. It works automatically when you wrap components in `<Suspense>` — no extra API calls required. React will even interrupt its current hydration work to prioritize a boundary the user is actively interacting with. The key to leveraging it is placing `<Suspense>` boundaries at logical UI seams — sidebars, modals, comment threads — and combining it with code splitting for the best performance. It's one of the core features that makes React 18's concurrent rendering practical for real production apps.
