---
title: GPU Acceleration
description: How to leverage the browser's GPU compositor to achieve smooth, performant CSS animations and transitions.
---

## Overview

By default, the browser renders your page on the CPU — it calculates layout, paints pixels, and composites layers all in a single pipeline. For most static content this is fine, but when you animate elements, this pipeline has to re-run constantly, which causes jank.

GPU acceleration offloads specific rendering work to the graphics card. The GPU is purpose-built for moving and blending rectangles of pixels at 60fps (or higher). When an element is "GPU-accelerated," the browser promotes it to its own **compositor layer**, hands it off to the GPU, and animates it there without touching the main thread.

The result: buttery-smooth animations even when the main thread is busy.

---

## How It Works

The browser rendering pipeline has three major phases:

1. **Layout** — calculate element sizes and positions
2. **Paint** — fill in the pixels for each element
3. **Composite** — layer the painted elements together and ship them to the screen

Layout and paint are expensive. Composite is cheap — it's what the GPU does natively.

When you animate properties that can be handled entirely at the composite stage (`transform` and `opacity`), the browser skips layout and paint entirely for that element. It uploads the element as a texture to the GPU once and then just moves/scales/fades that texture on subsequent frames.

Promoting an element to its own compositor layer is called **layer promotion**. You trigger it explicitly using the `will-change` property or implicitly with a 3D transform hack.

```
CPU thread:  [Layout] → [Paint] → uploads texture to GPU
GPU thread:  [Composite on every frame] ← cheap, off the main thread
```

<Callout type="info">
  Only `transform` and `opacity` are guaranteed to skip layout and paint.
  Animating `width`, `height`, `top`, `left`, `background-color`, etc. still
  triggers layout or paint, regardless of GPU acceleration.
</Callout>

---

## Code Examples

### 1. Correct: Animate with `transform` and `opacity`

```css
/* ✅ GPU-composited — no layout or paint triggered */
.card {
  transition:
    transform 300ms ease,
    opacity 300ms ease;
}

.card:hover {
  transform: translateY(-4px) scale(1.02);
  opacity: 0.9;
}
```

### 2. Incorrect: Animating layout-triggering properties

```css
/* ❌ Triggers layout on every frame — causes jank */
.card {
  transition:
    top 300ms ease,
    width 300ms ease;
  position: relative;
}

.card:hover {
  top: -4px;
  width: 105%;
}
```

Use `transform: translate()` and `transform: scale()` as drop-in replacements for `top`/`left` and `width`/`height` animations.

### 3. `will-change` for explicit layer promotion

Use `will-change` when you know an animation is about to start — for example, on hover or when a JS interaction is triggered.

```css
.modal-overlay {
  opacity: 0;
  /* Tell the browser to promote this element before the animation fires */
  will-change: opacity, transform;
  transition:
    opacity 250ms ease,
    transform 250ms ease;
}

.modal-overlay.is-visible {
  opacity: 1;
  transform: translateY(0);
}
```

<Callout type="warn">
  Do not apply `will-change` to every element as a blanket optimization. Each
  promoted layer consumes GPU memory. Overuse causes more harm than good —
  especially on mobile devices with limited VRAM.
</Callout>

### 4. The legacy 3D transform hack (and when to avoid it)

Before `will-change` was widely supported, developers forced layer promotion with a no-op 3D transform:

```css
/* Legacy technique — avoid in new code */
.animated-element {
  transform: translateZ(0);
  /* or */
  transform: translate3d(0, 0, 0);
}
```

This still works, but `will-change: transform` is the correct modern approach. Use the 3D hack only if you need to support very old browsers.

### 5. Real animation example: slide-in drawer

```css
/* drawer.css */

.drawer {
  position: fixed;
  right: 0;
  top: 0;
  height: 100vh;
  width: 320px;
  background: #fff;

  /* Start off-screen to the right */
  transform: translateX(100%);

  /* Promote to compositor layer before any interaction */
  will-change: transform;

  transition: transform 350ms cubic-bezier(0.4, 0, 0.2, 1);
}

.drawer.is-open {
  /* GPU moves the texture — no layout, no paint */
  transform: translateX(0);
}
```

```tsx
// Drawer.tsx — minimal React component wiring
"use client";

import { useState } from "react";
import "./drawer.css";

export function Drawer({ children }: { children: React.ReactNode }) {
  const [open, setOpen] = useState(false);

  return (
    <>
      <button onClick={() => setOpen(true)}>Open</button>

      <div className={`drawer ${open ? "is-open" : ""}`}>
        <button onClick={() => setOpen(false)}>Close</button>
        {children}
      </div>
    </>
  );
}
```

---

## Real-World Use Case

An e-commerce product page has a quick-view modal that slides up from the bottom when a user clicks a product card. The modal needs to feel instant and smooth, especially on mid-range Android phones.

Without GPU acceleration, animating `bottom` or `height` causes the browser to recalculate layout on every frame — the animation stutters at 30fps or below.

By instead animating `transform: translateY()` from `100%` to `0`, the browser promotes the modal to a compositor layer and the GPU handles every frame. The main thread stays free to handle user input, and the animation runs at a consistent 60fps.

---

## Common Mistakes / Gotchas

**1. Animating the wrong properties**

The most common mistake is reaching for `left`, `top`, `width`, or `background-color` in animations. These always trigger layout or paint. Remap them:

| Avoid              | Use instead              |
| ------------------ | ------------------------ |
| `top` / `left`     | `transform: translate()` |
| `width` / `height` | `transform: scale()`     |
| `margin`           | `transform: translate()` |

**2. Blanket `will-change` application**

Applying `will-change: transform` in a global reset or to dozens of elements creates hundreds of compositor layers. Each layer is a texture that lives in GPU memory. On mobile devices this can crash the page or cause severe frame drops — the opposite of what you intended.

Apply `will-change` close in time to the animation start, and remove it when the animation is done if you are applying it via JavaScript:

```ts
element.addEventListener("mouseenter", () => {
  element.style.willChange = "transform";
});

element.addEventListener("animationend", () => {
  // Release the layer after the animation finishes
  element.style.willChange = "auto";
});
```

**3. Expecting GPU acceleration to fix poorly structured animations**

If you trigger layout thrashing (reading and writing DOM geometry in alternating calls) inside a `requestAnimationFrame` loop, GPU-composited properties won't save you. The bottleneck is on the main thread, not the compositor. Profile with Chrome DevTools' **Performance** panel and check for long tasks before reaching for GPU tricks.

**4. Forgetting `backface-visibility` on 3D flip effects**

When building card-flip animations with `rotateY`, both faces of the card are rendered even when invisible. Adding `backface-visibility: hidden` to each face tells the GPU to cull the rear face, halving the compositing work.

```css
.card-front,
.card-back {
  backface-visibility: hidden;
}
```

---

## Summary

GPU acceleration moves compositing work off the main thread and onto the graphics card by promoting elements to their own layers. Only `transform` and `opacity` animations benefit fully — other properties still trigger layout or paint. Use `will-change` to hint at upcoming animations, but apply it sparingly to avoid exhausting GPU memory. The core rule is simple: if it moves or fades, use `transform` and `opacity`. Everything else is a compromise.
