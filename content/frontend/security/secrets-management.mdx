---
title: Secrets Management
description: How to securely manage secrets in full-stack Next.js apps — keeping sensitive values server-side and out of frontend bundles.
---

## Overview

A "secret" is any value that must not be exposed to end users: API keys, database connection strings, JWT signing keys, third-party service credentials, and so on. In a Next.js application, the build process bundles JavaScript that ships to the browser. If a secret ends up in that bundle, anyone can open DevTools and read it.

Secrets management is the practice of ensuring sensitive values are:

- Stored outside of source control (never committed to Git)
- Loaded only in server-side code
- Never serialized into the client bundle

This is not optional. A leaked API key can result in financial damage, data breaches, or account takeovers within minutes.

---

## How It Works

Next.js distinguishes between two categories of environment variables:

**Server-only variables** — any variable that does not start with `NEXT_PUBLIC_`. These are available in Server Components, Route Handlers, Server Actions, and middleware. They are stripped from the client bundle at build time.

**Public variables** — variables prefixed with `NEXT_PUBLIC_`. These are intentionally inlined into the client bundle and visible to anyone. Use them only for non-sensitive config like a public analytics tracking ID or a public-facing API base URL.

The rule is simple:

> If it's a secret → no `NEXT_PUBLIC_` prefix → server-side only.

At runtime, Next.js reads environment variables from:

1. `.env.local` (local development, git-ignored)
2. `.env.production` / `.env.development` (committed defaults, no secrets)
3. The deployment platform's secret store (Vercel, Railway, AWS Secrets Manager, etc.)

The Node.js process running your server has access to all of them. The browser has access to none of them — unless you explicitly pass them down.

<Callout type="warn">
  Never prefix a secret with `NEXT_PUBLIC_`. Doing so inlines the value into
  every JavaScript chunk sent to the browser, regardless of where in your code
  you use it.
</Callout>

---

## Code Examples

### 1. Correct: Reading a secret inside a Server Component

```tsx
// app/dashboard/page.tsx
// This file runs only on the server. The secret never reaches the browser.

async function fetchUserData(userId: string) {
  const response = await fetch(
    `https://api.internal.example.com/users/${userId}`,
    {
      headers: {
        // INTERNAL_API_KEY is a server-only env var — no NEXT_PUBLIC_ prefix
        Authorization: `Bearer ${process.env.INTERNAL_API_KEY}`,
      },
      cache: "no-store",
    },
  );

  if (!response.ok) {
    throw new Error("Failed to fetch user data");
  }

  return response.json();
}

export default async function DashboardPage() {
  const user = await fetchUserData("user_42");

  return (
    <main>
      <h1>Welcome, {user.name}</h1>
      <p>Account tier: {user.tier}</p>
    </main>
  );
}
```

### 2. Correct: Reading a secret inside a Route Handler

```ts
// app/api/send-email/route.ts
import { NextRequest, NextResponse } from "next/server";

export async function POST(req: NextRequest) {
  const { to, subject, body } = await req.json();

  // RESEND_API_KEY is defined in .env.local and never exposed to the client
  const response = await fetch("https://api.resend.com/emails", {
    method: "POST",
    headers: {
      Authorization: `Bearer ${process.env.RESEND_API_KEY}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      from: "noreply@yourapp.com",
      to,
      subject,
      html: body,
    }),
  });

  if (!response.ok) {
    return NextResponse.json(
      { error: "Email delivery failed" },
      { status: 502 },
    );
  }

  return NextResponse.json({ success: true });
}
```

### 3. Correct: Accessing a secret in a Server Action

```ts
// app/actions/checkout.ts
"use server";

import Stripe from "stripe";

// Instantiate the Stripe client once, server-side only
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: "2024-04-10",
});

export async function createCheckoutSession(priceId: string) {
  const session = await stripe.checkout.sessions.create({
    mode: "payment",
    line_items: [{ price: priceId, quantity: 1 }],
    success_url: `${process.env.NEXT_PUBLIC_BASE_URL}/success`, // public base URL is fine
    cancel_url: `${process.env.NEXT_PUBLIC_BASE_URL}/cancel`,
  });

  return session.url;
}
```

### 4. `.env.local` setup

```bash
# .env.local — NEVER commit this file to Git

# Server-only secrets (no NEXT_PUBLIC_ prefix)
INTERNAL_API_KEY=sk_live_abc123
STRIPE_SECRET_KEY=sk_live_xyz789
RESEND_API_KEY=re_live_def456
DATABASE_URL=postgresql://user:password@host:5432/mydb

# Public config (safe to expose — not sensitive)
NEXT_PUBLIC_BASE_URL=https://yourapp.com
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_live_...
```

```bash
# .gitignore — ensure this is present
.env.local
.env*.local
```

### 5. Validating secrets at startup (recommended)

Catch missing secrets immediately when the server boots rather than at runtime when a user hits the affected route.

```ts
// lib/env.ts
// Import this module in your root layout or a top-level server file.

function requireEnv(name: string): string {
  const value = process.env[name];
  if (!value) {
    throw new Error(
      `Missing required environment variable: ${name}. ` +
        `Check your .env.local or deployment secret store.`,
    );
  }
  return value;
}

export const env = {
  stripeSecretKey: requireEnv("STRIPE_SECRET_KEY"),
  databaseUrl: requireEnv("DATABASE_URL"),
  resendApiKey: requireEnv("RESEND_API_KEY"),
  // Public vars are also fine to validate here
  baseUrl: requireEnv("NEXT_PUBLIC_BASE_URL"),
} as const;
```

<Callout type="info">
  Libraries like [t3-env](https://env.t3.gg) or [zod](https://zod.dev) can parse
  and validate all environment variables at build time with full type safety,
  which is a good pattern for larger projects.
</Callout>

---

## Real-World Use Case

You're building a SaaS app with Stripe payments. The Stripe SDK requires a **secret key** (`sk_live_...`) to create payment intents and a **publishable key** (`pk_live_...`) to initialize Stripe.js in the browser.

- `STRIPE_SECRET_KEY` → server-only, used in Server Actions and Route Handlers to call the Stripe API
- `NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY` → safe to expose, used client-side to load Stripe.js

A developer who accidentally prefixes the secret key with `NEXT_PUBLIC_` ships it to every visitor. Stripe's automated secret scanning may revoke it, but in the window between deploy and revocation, it can be exploited.

---

## Common Mistakes / Gotchas

**1. Using `NEXT_PUBLIC_` for secrets because you need them in a Client Component**

If a Client Component needs data derived from a secret (e.g., a user's API response), fetch the data server-side and pass only the result as a prop — not the key itself.

```tsx
// ❌ Wrong — exposes the key in the bundle
// NEXT_PUBLIC_OPENAI_KEY=sk-...

// ✅ Correct — call OpenAI in a Server Component or Route Handler,
// pass only the response text to the Client Component
```

**2. Logging secrets in error handlers**

```ts
// ❌ This logs the full Authorization header, including the secret
console.error("Request failed", req.headers);

// ✅ Log only what you need
console.error("Request failed with status", response.status);
```

**3. Committing `.env.local` or hardcoding values**

Even in a private repository, secrets in Git history are a risk. Rotate any key that has ever been committed, and add `.env*.local` to `.gitignore` before your first commit.

**4. Passing server env vars through `searchParams` or URLs**

It happens: a developer builds a debug URL like `/api/debug?key=${process.env.SECRET}`. This lands in server logs, browser history, and referrer headers.

**5. Importing server-only modules into Client Components**

Next.js will tree-shake some things, but it is not guaranteed to strip all server code from client bundles. Use the `server-only` package to enforce a hard boundary.

```ts
// lib/db.ts
import "server-only"; // Throws a build error if this module is imported client-side

import { Pool } from "pg";

export const db = new Pool({ connectionString: process.env.DATABASE_URL });
```

<Callout type="warn">
  Install `server-only` (`npm i server-only`) and add `import "server-only"` at
  the top of any module that reads secrets or connects to infrastructure.
  Next.js will throw a build-time error if that module is ever imported in a
  Client Component.
</Callout>

---

## Summary

Secrets belong exclusively in server-side code. In Next.js, omitting the `NEXT_PUBLIC_` prefix from an environment variable is the primary mechanism that keeps it out of the browser bundle. Validate all required secrets at server startup so misconfiguration fails loudly and early. Use the `server-only` package to enforce module-level boundaries, preventing accidental imports into Client Components. Store secrets in a git-ignored `.env.local` file locally and in your deployment platform's secret store in production — never in source control.
