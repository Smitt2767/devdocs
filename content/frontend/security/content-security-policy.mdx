---
title: Content Security Policy
description: A guide to implementing Content Security Policy (CSP) in modern web apps, including Next.js App Router configuration and common pitfalls.
---

## Overview

Content Security Policy (CSP) is an HTTP response header that tells the browser which resources — scripts, styles, images, fonts, and more — are allowed to load on your page. It's one of the most effective defenses against Cross-Site Scripting (XSS) attacks.

Without CSP, if an attacker injects a malicious `<script>` tag into your page, the browser will execute it without question. With CSP, you define an allowlist of trusted sources, and the browser blocks everything else.

CSP is delivered via the `Content-Security-Policy` HTTP header or a `<meta>` tag, though the header approach is strongly preferred for security.

---

## How It Works

CSP works by defining **directives** — rules that govern specific resource types. Each directive names a resource category and lists where that resource can come from.

```
Content-Security-Policy: default-src 'self'; script-src 'self' https://cdn.example.com; img-src *;
```

- `default-src 'self'` — fallback rule: only load resources from the same origin
- `script-src 'self' https://cdn.example.com` — scripts can come from your origin or that specific CDN
- `img-src *` — images can come from anywhere

When the browser receives a page with this header, it checks every resource request against these rules before loading it. Anything not explicitly allowed is blocked and optionally reported.

### Nonces and Hashes

Inline scripts (`<script>...</script>`) are blocked by CSP by default because they're a common XSS vector. To allow specific inline scripts safely, use a **nonce** — a random, single-use token injected into both the header and the script tag.

```
Content-Security-Policy: script-src 'nonce-abc123xyz'
```

```html
<script nonce="abc123xyz">
  console.log("This inline script is trusted");
</script>
```

A new nonce must be generated per request so attackers can't predict it.

<Callout type="warn">
  Never use `unsafe-inline` or `unsafe-eval` in `script-src` unless you have no
  other option. These directives effectively disable XSS protection for scripts.
</Callout>

---

## Code Examples

### Next.js App Router — CSP via Middleware with Nonces

This is the recommended approach for Next.js apps using the App Router. Middleware runs on every request and can generate a fresh nonce and set the header.

```ts
// middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

export function middleware(request: NextRequest) {
  // Generate a cryptographically random nonce for this request
  const nonce = Buffer.from(crypto.randomUUID()).toString("base64");

  const csp = [
    `default-src 'self'`,
    `script-src 'self' 'nonce-${nonce}' 'strict-dynamic'`,
    `style-src 'self' 'nonce-${nonce}'`,
    `img-src 'self' blob: data: https:`,
    `font-src 'self'`,
    `object-src 'none'`,
    `base-uri 'self'`,
    `form-action 'self'`,
    `frame-ancestors 'none'`,
    `upgrade-insecure-requests`,
  ].join("; ");

  const requestHeaders = new Headers(request.headers);
  // Make the nonce available to Server Components via a header
  requestHeaders.set("x-nonce", nonce);
  requestHeaders.set("content-security-policy", csp);

  const response = NextResponse.next({ request: { headers: requestHeaders } });
  response.headers.set("content-security-policy", csp);

  return response;
}

export const config = {
  matcher: [
    // Apply to all routes except static files and Next.js internals
    "/((?!_next/static|_next/image|favicon.ico).*)",
  ],
};
```

### Reading the Nonce in a Server Component

```tsx
// app/layout.tsx
import { headers } from "next/headers";

export default async function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  // Read the nonce set by middleware
  const nonce = (await headers()).get("x-nonce") ?? "";

  return (
    <html lang="en">
      <head>
        {/* Inject a trusted inline script using the nonce */}
        <script
          nonce={nonce}
          dangerouslySetInnerHTML={{
            __html: `window.__APP_ENV__ = "production";`,
          }}
        />
      </head>
      <body>{children}</body>
    </html>
  );
}
```

### CSP-Only (No Nonce) via next.config.ts Headers

If you don't need inline scripts, you can set a static CSP via `next.config.ts`. This is simpler but less flexible.

```ts
// next.config.ts
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  async headers() {
    return [
      {
        source: "/(.*)",
        headers: [
          {
            key: "Content-Security-Policy",
            value: [
              "default-src 'self'",
              "script-src 'self'",
              "style-src 'self'",
              "img-src 'self' https: data:",
              "font-src 'self'",
              "object-src 'none'",
              "frame-ancestors 'none'",
            ].join("; "),
          },
        ],
      },
    ];
  },
};

export default nextConfig;
```

<Callout type="info">
  Use `Content-Security-Policy-Report-Only` instead of `Content-Security-Policy`
  while testing. It logs violations to the console (or a report endpoint)
  without actually blocking anything, so you can tune your policy safely before
  enforcing it.
</Callout>

### Setting Up a Violation Report Endpoint

```ts
// app/api/csp-report/route.ts
import { NextRequest, NextResponse } from "next/server";

export async function POST(request: NextRequest) {
  const report = await request.json();

  // Log to your observability platform (Datadog, Sentry, etc.)
  console.error("[CSP Violation]", JSON.stringify(report, null, 2));

  return NextResponse.json({ received: true }, { status: 204 });
}
```

Add `report-to` to your CSP header to wire it up:

```
Content-Security-Policy: ...; report-uri /api/csp-report
```

---

## Real-World Use Case

Consider an e-commerce storefront built on Next.js. It loads scripts from a payment provider (e.g., Stripe.js), images from a CDN, and fonts from Google Fonts. Without CSP, a compromised npm package or a third-party script could inject a keylogger that steals credit card numbers.

With CSP, you explicitly allow:

```
script-src 'self' https://js.stripe.com 'nonce-{perRequestNonce}';
img-src 'self' https://cdn.mystore.com;
font-src 'self' https://fonts.gstatic.com;
frame-src https://js.stripe.com;
```

Now, even if a malicious script tag is somehow injected into the page, the browser won't execute it — it doesn't have a valid nonce and doesn't come from an approved source.

---

## Common Mistakes / Gotchas

**1. Using `unsafe-inline` because it's easier**

Developers often add `'unsafe-inline'` to unblock a failing inline script instead of implementing nonces. This completely defeats XSS protection for scripts. The correct fix is to add a nonce to the script or move it to an external file.

**2. Forgetting that nonces must be regenerated per request**

A static nonce is no better than no nonce. If you hard-code a nonce or generate it once at build time, an attacker can harvest it and use it in injected scripts. Always generate nonces in middleware or a request handler.

**3. Not accounting for `strict-dynamic`**

When using nonces, add `'strict-dynamic'` to `script-src`. This tells the browser to trust scripts loaded _by_ a nonced script (e.g., a dynamically inserted `<script>` tag created by Stripe.js). Without it, those dynamically loaded scripts are blocked.

```
script-src 'nonce-{nonce}' 'strict-dynamic'
```

**4. Setting CSP only in `<meta>` tags**

A `<meta http-equiv="Content-Security-Policy">` tag in your HTML _does_ work for some directives, but it's loaded after the browser has already begun parsing the document. Scripts in the `<head>` before the meta tag may have already been evaluated. Always prefer the HTTP header.

**5. Breaking Next.js internals**

Next.js injects inline scripts for hydration, routing state, and image optimization. If your CSP blocks these, your app will silently break. Always use the nonce approach described above so Next.js's own scripts receive a valid nonce. Check the [Next.js CSP docs](https://nextjs.org/docs/app/building-your-application/configuring/content-security-policy) when upgrading framework versions, as the inline script patterns can change.

<Callout type="warn">
  After deploying a new CSP policy, monitor your
  `Content-Security-Policy-Report-Only` violations for at least 24–48 hours
  before switching to enforcement mode. One overlooked source can break
  authentication flows, analytics, or payment integrations for real users.
</Callout>

---

## Summary

Content Security Policy is an HTTP header that restricts what resources a browser can load, making XSS attacks significantly harder to exploit. In Next.js App Router projects, the recommended implementation uses Middleware to generate a per-request nonce, which is passed to Server Components via a custom header and applied to any trusted inline scripts. Always pair nonces with `'strict-dynamic'` and avoid shortcuts like `'unsafe-inline'`. Use `Content-Security-Policy-Report-Only` with a report endpoint to validate your policy safely before enforcing it in production.
