---
title: Overview
description: A structured reference of frontend engineering concepts — covering rendering, performance, architecture, and everything in between.
---

# Frontend Engineering

This section is a curated, in-depth reference for frontend engineering. Each article goes beyond surface-level explanations — the goal is to understand _why_ things work the way they do, not just how to copy a pattern.

Topics are organized into 16 categories in a deliberate order — from the JavaScript engine at the foundation, through the rendering pipeline and component layer, out to delivery and architecture. Reading front-to-back is a complete walkthrough. Use the sidebar to jump to any topic.

---

## JavaScript Runtime & Async

Covers the JavaScript engine and async execution model that everything else builds on.

Topics include: the event loop (macrotasks vs microtasks), task starvation and scheduler priorities, promise combinators and error propagation, async/await and error handling, AbortController and streaming fetch, and concurrency vs parallelism.

---

## Rendering & Browser Pipeline

Covers how browsers turn HTML, CSS, and JavaScript into pixels — and how React's rendering model maps onto that pipeline.

Topics include: the critical rendering path, render-blocking resources, paint vs composite vs layout, browser compositing layers, hydration, hydration strategies, streaming SSR, SSR vs SSG vs ISR, the RSC rendering model, concurrent rendering, fiber architecture, the reconciliation algorithm, render waterfalls, the View Transitions API, and image and font optimization.

---

## CSS & Layout

Covers CSS at the systems level — not syntax, but architecture and performance.

Topics include: CSS architecture trade-offs, CSS containment, layout thrashing, animation performance, theming and design tokens, and responsive design strategies.

---

## Component & UI Architecture

Covers how to structure the UI layer at a component and system level.

Topics include: React Server Components, Suspense boundaries, error boundaries, compound components, the headless UI pattern, portal and layering architecture, Shadow DOM, edge rendering, and micro-frontend orchestration.

---

## State Management & Data Patterns

Covers how state flows through an application — including the edge cases that cause subtle bugs.

Topics include: derived state vs redundant state, immutable data patterns, memoization pitfalls, state boundaries, URL as state, data fetching patterns, race conditions in UI state, optimistic UI and rollback strategy, idempotent UI actions, and offline conflict resolution.

---

## Bundling & Code Delivery

Covers how code gets from your editor to the browser — and how to make that process faster and leaner.

Topics include: tree shaking internals, code splitting strategies, bundle analysis and dependency auditing, preload / prefetch / preconnect / priority hints, module federation, and monorepo tooling.

---

## Caching & Storage

Covers caching at every layer — HTTP, CDN, service worker, and client-side storage.

Topics include: HTTP caching strategies, cache invalidation strategies, CDN cache purging, service worker lifecycle traps, IndexedDB, and offline conflict resolution.

---

## Networking & Protocols

Covers the network layer between your frontend and the server.

Topics include: HTTP/3 and QUIC, CORS and preflight, SameSite cookie modes, authentication flows, API paradigms (REST, GraphQL, tRPC), WebSockets vs SSE vs long polling, and client-side rate limiting.

---

## Security

Covers the attack vectors and mitigations most relevant to frontend engineers.

Topics include: CSRF vs XSS mitigation, Content Security Policy, Trusted Types, secrets management, prototype pollution, and dependency and supply chain risks.

---

## Performance & Core Web Vitals

Covers measurable, user-impacting performance — from individual metrics to CI enforcement.

Topics include: Largest Contentful Paint, Cumulative Layout Shift, Interaction to Next Paint, third-party script management, RUM vs synthetic monitoring, performance budgets, and Lighthouse CI integration.

---

## Browser Observation APIs

Covers the browser APIs used to observe DOM changes, visibility, and performance — without polling.

Topics include: IntersectionObserver internals, MutationObserver cost, the PerformanceObserver API, and the Long Tasks API.

---

## Memory & Garbage Collection

Covers how the browser allocates and reclaims memory — and how to find and fix leaks.

Topics include: garbage collection timing, browser memory leak detection, detached DOM nodes, and memory profiling with Chrome DevTools.

---

## Concurrency & Workers

Covers how to move work off the main thread using browser worker primitives.

Topics include: Web Workers vs Service Workers.

---

## Accessibility

Covers building UIs that work for all users — including the underlying browser and AT mechanics.

Topics include: the accessibility tree, ARIA live regions internals, focus management in SPAs, keyboard navigation patterns, pointer events, and color contrast and reduced motion.

---

## DevX & Delivery

Covers the engineering systems around shipping software reliably and safely.

Topics include: CI/CD pipelines for frontend, feature flags and progressive rollouts, error tracking and observability, design system ownership and versioning, and internationalization (i18n) architecture.

---

## Architecture & Decision Making

Covers the higher-order thinking required to make durable technical decisions.

Topics include: framework selection criteria, API contract design, Architecture Decision Records (ADRs), and technical debt identification and prioritization.

---

<Callout type="info">
  This section is actively maintained. New articles are added as topics are
  covered. If a category only has one or two articles, more are on the way.
</Callout>
