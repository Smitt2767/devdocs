---
title: HTTP Caching Hierarchy
description: A practical guide to how browsers, disks, CDNs, and origin servers form a layered HTTP caching system — and how to control each layer.
---

## Overview

When a browser requests a resource, that request rarely needs to travel all the way to your origin server. HTTP caching is a layered system where each layer can serve a response before passing the request further down the chain. The four layers — memory cache, disk cache, CDN (or reverse proxy), and origin server — each have different speeds, lifetimes, and invalidation strategies.

Understanding this hierarchy lets you write smarter `Cache-Control` headers, reduce infrastructure costs, and dramatically improve perceived performance.

## How It Works

Think of the caching hierarchy like a series of checkpoints a request passes through. Each checkpoint either satisfies the request immediately or forwards it to the next layer.

```
Browser Request
      │
      ▼
┌─────────────────┐
│  Memory Cache   │  ← Fastest. Lives in RAM. Gone on tab close.
└────────┬────────┘
         │ miss
         ▼
┌─────────────────┐
│   Disk Cache    │  ← Slower. Persists across sessions. Stored on filesystem.
└────────┬────────┘
         │ miss
         ▼
┌─────────────────┐
│   CDN / Edge    │  ← Shared cache. Serves many users. Geographically distributed.
└────────┬────────┘
         │ miss
         ▼
┌─────────────────┐
│  Origin Server  │  ← Source of truth. Always slowest. Should be hit rarely.
└─────────────────┘
```

**Memory Cache**
Stores resources already fetched during the current page session. Inline `<script>` tags and `<link rel="preload">` resources often land here. The browser controls this layer entirely — you cannot directly configure it via headers. It is cleared when the tab is closed.

**Disk Cache**
Persists across browser sessions. Controlled by `Cache-Control` and `Expires` headers. When you revisit a site after closing and reopening the browser, cached CSS and JS often come from here.

**CDN / Reverse Proxy**
A shared cache that sits between users and your origin. A single CDN edge node can serve one cached response to thousands of users. CDNs respect `Cache-Control: s-maxage` (shared cache directive) and can be purged via APIs. Examples: Cloudflare, Vercel Edge Network, Fastly.

**Origin Server**
Your actual application — a Next.js server, an Express API, etc. Every cache miss upstream eventually reaches here. The origin sets the authoritative `Cache-Control` headers that all downstream layers read.

## How Cache-Control Directives Map to the Hierarchy

| Directive                          | Affects                                           |
| ---------------------------------- | ------------------------------------------------- |
| `max-age=<seconds>`                | Browser memory + disk cache                       |
| `s-maxage=<seconds>`               | CDN / shared caches only                          |
| `no-store`                         | Disables all caching at every layer               |
| `no-cache`                         | Forces revalidation before serving from any cache |
| `private`                          | Allows browser caching, blocks CDN caching        |
| `public`                           | Allows caching at all layers including CDNs       |
| `stale-while-revalidate=<seconds>` | Serves stale while refreshing in background       |

## Code Examples

### Setting headers on a Next.js Route Handler

```ts
// app/api/products/route.ts
import { NextResponse } from "next/server";

export async function GET() {
  const products = await fetchProductsFromDatabase();

  return NextResponse.json(products, {
    headers: {
      // CDN caches for 60s, browser caches for 30s
      // Serve stale for up to 10s while revalidating in background
      "Cache-Control":
        "public, s-maxage=60, max-age=30, stale-while-revalidate=10",
    },
  });
}

async function fetchProductsFromDatabase() {
  // Replace with your actual DB call
  return [{ id: 1, name: "Widget", price: 29.99 }];
}
```

### Caching a Next.js Server Component with fetch

```tsx
// app/products/page.tsx
// This is a Server Component by default — no 'use client' needed

export default async function ProductsPage() {
  // next.revalidate controls the CDN/server-side cache lifetime (ISR)
  const response = await fetch("https://api.example.com/products", {
    next: { revalidate: 60 }, // revalidate at most every 60 seconds
  });

  const products = await response.json();

  return (
    <ul>
      {products.map((product: { id: number; name: string; price: number }) => (
        <li key={product.id}>
          {product.name} — ${product.price}
        </li>
      ))}
    </ul>
  );
}
```

### Bypassing the CDN for user-specific data

```ts
// app/api/cart/route.ts
import { NextResponse } from "next/server";
import { getSessionUser } from "@/lib/auth";

export async function GET(request: Request) {
  const user = await getSessionUser(request);
  const cart = await fetchCartForUser(user.id);

  return NextResponse.json(cart, {
    headers: {
      // private: browser can cache, but CDN must NOT cache this response
      // max-age=0: browser must revalidate every time
      "Cache-Control": "private, max-age=0, must-revalidate",
    },
  });
}

async function fetchCartForUser(userId: string) {
  return { userId, items: [] }; // Replace with real DB call
}
```

<Callout type="warn">
  Never cache user-specific data (cart contents, account info, session data)
  without `private`. Without it, a CDN may serve one user's data to another
  user.
</Callout>

### Opting out of all caching

```ts
// app/api/live-score/route.ts
import { NextResponse } from "next/server";

export async function GET() {
  const score = await fetchLiveScore();

  return NextResponse.json(score, {
    headers: {
      // no-store: nothing is cached anywhere — not browser, not CDN
      "Cache-Control": "no-store",
    },
  });
}

async function fetchLiveScore() {
  return { home: 2, away: 1, minute: 74 };
}
```

## Real-World Use Case

On an e-commerce storefront, the product listing page is viewed by thousands of users per minute. The data changes roughly every few minutes (inventory, pricing).

- The product listing API uses `public, s-maxage=120, stale-while-revalidate=30` so the CDN serves a cached response for 2 minutes, then refreshes in the background without the user waiting.
- Static assets (JS bundles, fonts, images) use `public, max-age=31536000, immutable` — cached aggressively at the disk layer for one year since their URLs include a content hash.
- The `/checkout` page and cart API use `private, no-store` — no caching anywhere because this data is user-specific and must always be fresh.

This combination means the origin server handles only a fraction of the actual request volume.

## Common Mistakes / Gotchas

**1. Forgetting `private` on authenticated endpoints**

If you set `Cache-Control: max-age=60` without `private` on a response containing user data, a CDN will cache it and serve it to every subsequent user who hits that endpoint. Always audit your authenticated routes.

**2. Confusing `max-age` and `s-maxage`**

`max-age` controls both browser and CDN caches unless `s-maxage` is explicitly set. `s-maxage` is CDN-only and overrides `max-age` for shared caches. Set both when you want different TTLs for browser vs. CDN.

```ts
// CDN caches for 5 minutes, browser caches for 30 seconds
'Cache-Control': 'public, s-maxage=300, max-age=30'
```

**3. Using `no-cache` when you mean `no-store`**

`no-cache` does **not** mean "do not cache." It means "cache it, but always revalidate with the origin before serving it." If you want a response never stored anywhere, use `no-store`. These two directives are commonly swapped.

**4. Neglecting cache invalidation at the CDN layer**

Setting `s-maxage=86400` (24 hours) and then deploying updated content means users can see stale data for up to a day. Always pair long CDN TTLs with a purge strategy — either use content-hashed URLs (for static assets) or call your CDN's purge API on deploy for dynamic routes.

<Callout type="info">
  Vercel automatically purges CDN cache for Next.js routes that use `revalidate`
  or on-demand revalidation via `revalidatePath()` / `revalidateTag()`.
</Callout>

**5. Assuming memory cache is controllable**

The browser's in-memory cache is managed entirely by the browser engine. You cannot target it with headers. Focus your `Cache-Control` strategy on disk cache (via `max-age`) and CDN (via `s-maxage`).

## Summary

HTTP caching operates as a four-layer hierarchy: memory, disk, CDN, and origin. Each layer is faster and cheaper to serve from than the next. `Cache-Control` headers are the primary mechanism for controlling behavior at each layer, with `max-age` targeting browser caches and `s-maxage` targeting shared/CDN caches. The `private` directive is critical for protecting user-specific data from being cached at the CDN layer. Designing your caching strategy around this hierarchy — aggressive caching for public static content, no caching for authenticated data — is one of the highest-leverage performance and cost optimizations available in web development.
