---
title: Offline Conflict Resolution
description: How to detect, manage, and resolve data conflicts that arise when offline-capable web apps sync changes back to a server.
---

## Overview

When a web app supports offline usage, users can make changes while disconnected. When they reconnect, those local changes need to sync to the server — but the server may have already received conflicting updates from another client or session.

**Offline conflict resolution** is the set of strategies and implementation patterns used to detect these conflicts and decide which version of data wins, or how to merge both.

This affects any app using:

- Service Workers + background sync
- Local-first databases (PouchDB, IndexedDB, Replicache, TinyBase)
- Optimistic UI updates
- Collaborative editing features

---

## How It Works

At the core, every conflict involves three versions of a piece of data:

| Version    | Description                                                 |
| ---------- | ----------------------------------------------------------- |
| **Base**   | The last known server state when the client went offline    |
| **Local**  | What the client changed while offline                       |
| **Remote** | What the server (or another client) changed in the meantime |

When a sync occurs, you compare all three. If local and remote both differ from the base, you have a conflict.

**Resolution strategies:**

- **Last Write Wins (LWW):** Whichever change has the latest timestamp wins. Simple but lossy.
- **Server Wins:** Discard local changes entirely on conflict. Safe but frustrating to users.
- **Client Wins:** Always apply local changes. Risk of overwriting valid server updates.
- **Three-Way Merge:** Use the base + local + remote to compute a merged result. Most correct, most complex.
- **User-Prompted Resolution:** Surface conflicts to the user and let them choose. Best for high-stakes data.

Most real apps combine strategies: auto-merge where safe, prompt the user only when necessary.

<Callout type="info">
  CRDTs (Conflict-free Replicated Data Types) are a more advanced approach that
  make certain data structures (counters, sets, text) mathematically
  conflict-free by design. Libraries like Automerge and Yjs implement this.
</Callout>

---

## Code Examples

### 1. Detecting a Conflict During Sync

Use a `version` or `updatedAt` field on every record to detect if the server state has diverged from the base the client knew about.

```ts
// lib/sync.ts

type SyncRecord = {
  id: string;
  data: Record<string, unknown>;
  updatedAt: number; // Unix ms timestamp
};

type ConflictResult =
  | { status: "ok"; resolved: SyncRecord }
  | { status: "conflict"; local: SyncRecord; remote: SyncRecord };

async function syncRecord(
  localChange: SyncRecord,
  baseUpdatedAt: number, // the updatedAt when the client last fetched this record
): Promise<ConflictResult> {
  const response = await fetch(`/api/records/${localChange.id}`);
  const remote: SyncRecord = await response.json();

  // If the server record changed after our last known base, we have a conflict
  const hasConflict = remote.updatedAt > baseUpdatedAt;

  if (!hasConflict) {
    // Safe to apply local change
    const saved = await applyChange(localChange);
    return { status: "ok", resolved: saved };
  }

  return { status: "conflict", local: localChange, remote };
}

async function applyChange(record: SyncRecord): Promise<SyncRecord> {
  const res = await fetch(`/api/records/${record.id}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(record),
  });
  return res.json();
}
```

---

### 2. Three-Way Merge for a Simple Object

For flat objects, a three-way merge applies whichever side changed a given field, and flags fields where both sides changed.

```ts
// lib/merge.ts

type PlainRecord = Record<string, unknown>;

type MergeResult = {
  merged: PlainRecord;
  conflicts: string[]; // field names that couldn't be auto-resolved
};

export function threeWayMerge(
  base: PlainRecord,
  local: PlainRecord,
  remote: PlainRecord,
): MergeResult {
  const merged: PlainRecord = { ...base };
  const conflicts: string[] = [];

  const allKeys = new Set([...Object.keys(local), ...Object.keys(remote)]);

  for (const key of allKeys) {
    const baseVal = base[key];
    const localVal = local[key];
    const remoteVal = remote[key];

    const localChanged = localVal !== baseVal;
    const remoteChanged = remoteVal !== baseVal;

    if (localChanged && remoteChanged && localVal !== remoteVal) {
      // Both sides changed this field to different values — true conflict
      conflicts.push(key);
      // Default to remote, but flag it for user review
      merged[key] = remoteVal;
    } else if (localChanged) {
      merged[key] = localVal;
    } else {
      merged[key] = remoteVal;
    }
  }

  return { merged, conflicts };
}
```

Usage:

```ts
import { threeWayMerge } from "@/lib/merge";

const base = { title: "Draft", status: "active" };
const local = { title: "Final", status: "active" }; // user renamed
const remote = { title: "Draft", status: "archived" }; // server archived

const { merged, conflicts } = threeWayMerge(base, local, remote);
// merged   → { title: "Final", status: "archived" }
// conflicts → [] — no conflict, different fields changed
```

---

### 3. Server-Side Conflict Check with Optimistic Locking

Use an `ETag` or version counter on the server to reject stale writes.

```ts
// app/api/records/[id]/route.ts
import { NextRequest, NextResponse } from "next/server";
import { db } from "@/lib/db";

export async function PUT(
  req: NextRequest,
  { params }: { params: { id: string } },
) {
  const body = await req.json();
  const { data, expectedVersion } = body as {
    data: Record<string, unknown>;
    expectedVersion: number;
  };

  const current = await db.record.findUnique({ where: { id: params.id } });

  if (!current) {
    return NextResponse.json({ error: "Not found" }, { status: 404 });
  }

  if (current.version !== expectedVersion) {
    // Optimistic lock failed — client is working from a stale base
    return NextResponse.json(
      {
        error: "conflict",
        serverRecord: current, // send back the latest so client can merge
      },
      { status: 409 },
    );
  }

  const updated = await db.record.update({
    where: { id: params.id },
    data: { ...data, version: current.version + 1 },
  });

  return NextResponse.json(updated);
}
```

```ts
// Client-side: handle 409 conflict response
async function saveRecord(id: string, data: object, knownVersion: number) {
  const res = await fetch(`/api/records/${id}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ data, expectedVersion: knownVersion }),
  });

  if (res.status === 409) {
    const { serverRecord } = await res.json();
    // Hand off to your merge/UI conflict resolution flow
    return handleConflict(data, serverRecord);
  }

  return res.json();
}
```

---

### 4. User-Prompted Conflict Resolution UI

```tsx
// components/ConflictResolver.tsx
"use client";

import { useState } from "react";

type ConflictField = {
  key: string;
  localValue: unknown;
  remoteValue: unknown;
};

type Props = {
  conflicts: ConflictField[];
  onResolve: (resolutions: Record<string, unknown>) => void;
};

export function ConflictResolver({ conflicts, onResolve }: Props) {
  const [choices, setChoices] = useState<Record<string, "local" | "remote">>(
    Object.fromEntries(conflicts.map((c) => [c.key, "remote"])),
  );

  function handleSubmit() {
    const resolutions = Object.fromEntries(
      conflicts.map((c) => [
        c.key,
        choices[c.key] === "local" ? c.localValue : c.remoteValue,
      ]),
    );
    onResolve(resolutions);
  }

  return (
    <div className="conflict-resolver">
      <h2>Resolve Sync Conflicts</h2>
      <p>
        Some fields were changed in both places. Choose which version to keep.
      </p>

      {conflicts.map((conflict) => (
        <div key={conflict.key} className="conflict-field">
          <strong>{conflict.key}</strong>
          <label>
            <input
              type="radio"
              name={conflict.key}
              value="local"
              checked={choices[conflict.key] === "local"}
              onChange={() =>
                setChoices((prev) => ({ ...prev, [conflict.key]: "local" }))
              }
            />
            Your version: <code>{String(conflict.localValue)}</code>
          </label>
          <label>
            <input
              type="radio"
              name={conflict.key}
              value="remote"
              checked={choices[conflict.key] === "remote"}
              onChange={() =>
                setChoices((prev) => ({ ...prev, [conflict.key]: "remote" }))
              }
            />
            Server version: <code>{String(conflict.remoteValue)}</code>
          </label>
        </div>
      ))}

      <button onClick={handleSubmit}>Apply Resolutions</button>
    </div>
  );
}
```

---

## Real-World Use Case

A project management app lets users edit task descriptions and statuses while offline on mobile. When they regain connectivity:

1. The app checks each dirty (locally modified) record against the server using version numbers.
2. Non-conflicting changes (only one side modified a field) are auto-merged silently.
3. A task where the user changed the title offline _and_ a teammate changed the status server-side gets auto-merged (different fields).
4. A task where both the user and a teammate edited the description surfaces the `ConflictResolver` UI so the user consciously picks a version.
5. Once resolved, the merged record is written back to the server with the latest version number.

---

## Common Mistakes / Gotchas

**Using timestamps alone for conflict detection**

Wall-clock timestamps are unreliable — clocks on different devices drift. Use a server-assigned monotonic version counter or vector clock instead of `Date.now()` on the client.

**Silently overwriting with Last Write Wins on all fields**

LWW feels simple but destroys data. A user who spent 10 minutes writing a form while offline can have all their work silently discarded. Only use LWW for genuinely low-stakes, append-only data like analytics events.

**Not storing the base snapshot locally**

To do any three-way merge, you need the _base_ — what the data looked like when the client last synced. Many developers store only the local current state and then can't distinguish "user changed this field" from "this field was always different." Store the last-synced snapshot in IndexedDB alongside the pending change.

**Assuming the server is always the source of truth**

In collaborative or local-first apps, blindly deferring to the server breaks user trust. Design a clear policy per data type: some fields (e.g., audit timestamps set by the server) should always come from the server; others (user-authored content) deserve the conflict resolution flow.

<Callout type="warn">
  Never silently discard user data. If you can't auto-merge, always surface the
  conflict to the user or log it for later manual review. Silent data loss is
  worse than a visible merge conflict.
</Callout>

---

## Summary

Offline conflict resolution is required any time users can modify data without a live server connection. The key is storing a base snapshot at sync time, comparing base + local + remote on reconnect, and applying an appropriate strategy per data type. Three-way merging handles most non-overlapping changes automatically. Optimistic locking with version numbers on the server prevents accidental overwrites. Reserve user-prompted resolution for high-value data where automated merging is unsafe. Libraries like Replicache, Automerge, and Yjs can handle much of this complexity for you in production apps.
