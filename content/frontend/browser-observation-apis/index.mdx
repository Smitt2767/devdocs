---
title: Overview
description: The browser Observer APIs that replace polling with a push model — IntersectionObserver for visibility, MutationObserver for DOM mutations, PerformanceObserver for metrics, and the Long Tasks API for main-thread blocking detection.
---

## Browser Observation APIs

Before these APIs existed, developers polled — running `setInterval` to check scroll position, `setTimeout` to detect DOM changes, and manual timers to measure performance. Polling is expensive, imprecise, and fights the browser's own scheduling. The Observer APIs replaced polling with a push model: you declare what you want to observe, and the browser notifies you efficiently when something changes.

The section is ordered by how frequently each API appears in production frontend code.

---

## What's Covered

**IntersectionObserver Internals** — The browser's asynchronous intersection loop: callbacks fire after layout and paint, never in the middle of a scroll tick. `root` (viewport or scrollable ancestor), `rootMargin` (pre-loading expansion), and `threshold` (single or array). `IntersectionObserverEntry` properties: `isIntersecting`, `intersectionRatio`, `boundingClientRect`, `intersectionRect`, `time`, `target`. `unobserve(el)` vs `disconnect()`: stop watching one element vs full teardown. One observer for many elements via `entry.target`. Lazy loading with `rootMargin: "200px"`. Infinite scroll sentinel pattern. Analytics impression tracking (IAB: ≥50% visible for ≥1 second) with threshold array and `clearTimeout` on exit. Scrollable container roots requiring `overflow` CSS for `rootMargin` to work. SSR guard (`typeof IntersectionObserver !== 'undefined'`).

**MutationObserver Cost** — Microtask delivery model: batched after the current task, before the next macrotask. Configuration options: `childList`, `attributes`, `characterData`, `subtree`, `attributeOldValue`, `characterDataOldValue`, `attributeFilter`. Performance cost taxonomy: observation scope vs callback complexity vs observer leaks. `attributeFilter` to restrict attribute observation and avoid firing on `class`/`style` changes. `characterData` + `characterDataOldValue` for text node tracking in `contenteditable` elements. `takeRecords()` for synchronous buffer flush before disconnect. Expensive pattern (document.body with subtree+attributes) vs efficient pattern (scoped, debounced). Feedback loop risk: modifying observed nodes inside the callback. React integration with `useEffect` cleanup. `MutationObserver` vs `ResizeObserver` vs `IntersectionObserver` decision matrix.

**PerformanceObserver API** — Entry type reference: `"navigation"`, `"resource"`, `"paint"`, `"largest-contentful-paint"`, `"layout-shift"`, `"longtask"`, `"event"`, `"first-input"`, `"mark"`, `"measure"`. Single-type `observe({ type, buffered: true })` vs multi-type `observe({ entryTypes })` — `buffered` silently ignored in multi-type form. Why `buffered: true` is critical for LCP and CLS (candidates fire before JS bootstraps). `takeRecords()` for synchronous flush before disconnect. Resource timing: `transferSize`, `encodedBodySize`, `initiatorType`, `nextHopProtocol` for protocol audit. Custom instrumentation: `performance.mark()` + `performance.measure()` observed via `"measure"` type. Navigation timing Level 2: TTFB, DNS, TCP, load breakdown. `navigator.sendBeacon` as the correct reporting mechanism (survives page unload). `web-vitals` library for correct LCP finalization, CLS session windowing, and INP outlier handling.

**Long Tasks API** — Long task = any main-thread task >50ms. Causes: input event queueing → inflated INP. `PerformanceLongTaskTiming`: `duration`, `startTime`, `attribution` (often limited). `buffered: true` essential for catching load-time long tasks. User Timing correlation: `performance.mark()` bracketing, compare measure `startTime` with task window to identify which function is the cause. Breaking long tasks: `yieldToMain()` with `scheduler.yield()` fallback, `scheduler.postTask()` priority levels (`"user-blocking"`, `"user-visible"`, `"background"`), React `startTransition` for non-urgent state updates, `requestIdleCallback` with `timeout` for analytics. `navigator.scheduling.isInputPending()` for cooperative yielding only when the user is interacting. Long Animation Frames (LoAF) `"long-animation-frame"` as the successor: richer `scripts[]` attribution with `sourceURL`, `sourceCharPosition`, `invokerType`. Feature-detect LoAF via `PerformanceObserver.supportedEntryTypes`. Keep observer callbacks lightweight — defer heavy processing to idle time.
