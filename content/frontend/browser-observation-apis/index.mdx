---
title: Overview
description: The browser APIs used to observe DOM changes, visibility, and performance — without polling.
---

## Browser Observation APIs

Before these APIs existed, developers polled — running `setInterval` to check scroll position, `setTimeout` to detect DOM changes, and manual timers to measure performance. Polling is expensive, imprecise, and fights the browser's own scheduling. The Observer APIs replaced polling with a push model: you declare what you want to observe, and the browser notifies you efficiently when something changes.

The section is ordered by how frequently each API appears in production frontend code.

## What's covered

**IntersectionObserver Internals** — How the browser detects element visibility relative to a viewport or ancestor, how thresholds and root margins work, and the correct patterns for lazy loading, infinite scroll, and analytics impression tracking.

**MutationObserver Cost** — How to detect DOM changes without blocking the main thread, the performance cost of observing large subtrees, and when `MutationObserver` is the right tool versus a React state-driven approach.

**PerformanceObserver API** — The unified API for subscribing to performance entries — navigation timing, resource timing, paint timing, long tasks, and Core Web Vitals. How to buffer entries and report them to an analytics endpoint.

**Long Tasks API** — Detecting tasks that block the main thread for more than 50ms, attributing them to specific scripts or frames, and using this data to diagnose INP and TBT regressions.
