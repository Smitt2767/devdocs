---
title: PerformanceObserver API
description: A guide to using the PerformanceObserver API to asynchronously monitor and react to browser performance metrics in modern web applications.
---

## Overview

The `PerformanceObserver` API lets you listen for performance-related events in the browser asynchronously — without having to poll the `performance` timeline manually. It gives you access to metrics like Largest Contentful Paint (LCP), First Input Delay (FID), Cumulative Layout Shift (CLS), resource timing, long tasks, and more.

Instead of querying `performance.getEntriesByType()` on a timer, you register an observer and get notified automatically when new entries are recorded. This is the foundation of how tools like web-vitals and Lighthouse collect real-user metrics.

---

## How It Works

The browser continuously records performance entries into a timeline buffer. `PerformanceObserver` taps into that stream by registering a callback tied to one or more entry types (e.g., `"largest-contentful-paint"`, `"longtask"`, `"resource"`).

When a new entry matching your observed type is recorded, your callback fires with a `PerformanceObserverEntryList` — a batch of one or more entries you can iterate over.

Think of it like a `MutationObserver`, but for the browser's performance timeline instead of the DOM.

```
Browser records entry → PerformanceObserver callback fires → You inspect the entry
```

Each entry has a `name`, `entryType`, `startTime`, and `duration` at minimum. Specific entry types add extra properties (e.g., `element` on LCP entries, `processingStart` on event timing entries).

---

## Code Examples

### Basic Observer — Long Tasks

```ts
// Detect any task that blocks the main thread for >50ms
const observer = new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntries()) {
    console.warn(`Long task detected: ${entry.duration.toFixed(1)}ms`, entry);
  }
});

observer.observe({ type: "longtask", buffered: true });
// buffered: true captures entries that occurred before the observer was registered
```

### Collecting Core Web Vitals

```ts
import { onLCP, onCLS, onINP } from "web-vitals"; // wraps PerformanceObserver internally

onLCP((metric) => {
  // metric.value is in milliseconds
  sendToAnalytics({ name: "LCP", value: metric.value, id: metric.id });
});

onCLS((metric) => {
  // metric.value is a unitless score (lower is better)
  sendToAnalytics({ name: "CLS", value: metric.value, id: metric.id });
});

onINP((metric) => {
  sendToAnalytics({ name: "INP", value: metric.value, id: metric.id });
});

function sendToAnalytics(payload: { name: string; value: number; id: string }) {
  // Use sendBeacon so it fires even when the page is unloading
  navigator.sendBeacon("/api/vitals", JSON.stringify(payload));
}
```

### Manual LCP Observer

```ts
let lcpValue = 0;

const lcpObserver = new PerformanceObserver((entryList) => {
  const entries = entryList.getEntries();

  // LCP can update multiple times — always take the last entry
  const lastEntry = entries[entries.length - 1] as LargestContentfulPaint;
  lcpValue = lastEntry.startTime;
});

lcpObserver.observe({ type: "largest-contentful-paint", buffered: true });

// Stop observing on user interaction (LCP is finalized at this point)
["keydown", "pointerdown"].forEach((event) => {
  window.addEventListener(
    event,
    () => {
      lcpObserver.disconnect();
      console.log(`Final LCP: ${lcpValue.toFixed(1)}ms`);
    },
    { once: true },
  );
});
```

### Resource Timing — Detect Slow Third-Party Scripts

```ts
const resourceObserver = new PerformanceObserver((entryList) => {
  for (const entry of entryList.getEntries()) {
    const resource = entry as PerformanceResourceTiming;

    // Flag any resource taking longer than 500ms to load
    if (resource.duration > 500) {
      console.warn(
        `Slow resource: ${resource.name} — ${resource.duration.toFixed(0)}ms`,
      );
    }
  }
});

resourceObserver.observe({ type: "resource", buffered: true });
```

### Using in a Next.js App Router Component

```tsx
// app/_components/vitals-tracker.tsx
"use client";

import { useEffect } from "react";

export function VitalsTracker() {
  useEffect(() => {
    if (typeof PerformanceObserver === "undefined") return;

    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.entryType === "largest-contentful-paint") {
          const lcp = entry as LargestContentfulPaint;
          navigator.sendBeacon(
            "/api/vitals",
            JSON.stringify({ metric: "LCP", value: lcp.startTime }),
          );
        }
      }
    });

    observer.observe({ type: "largest-contentful-paint", buffered: true });

    // Clean up when the component unmounts
    return () => observer.disconnect();
  }, []);

  // This component renders nothing — it's a side-effect-only tracker
  return null;
}
```

```tsx
// app/layout.tsx
import { VitalsTracker } from "./_components/vitals-tracker";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        {children}
        <VitalsTracker />
      </body>
    </html>
  );
}
```

<Callout type="info">
  `VitalsTracker` must be a Client Component (`"use client"`) because
  `useEffect` and browser APIs like `PerformanceObserver` are not available in
  Server Components.
</Callout>

---

## Real-World Use Case

In a SaaS dashboard with complex data tables, you notice users complain the page feels sluggish after filtering. You set up a `longtask` observer in development and find a 300ms task firing every time a filter is applied — traced to a synchronous array sort on 10,000 rows. You also attach an LCP observer to your `/dashboard` route via `VitalsTracker` and pipe the data to your analytics backend. This gives you a real-user performance baseline before and after you move the sort to a Web Worker.

---

## Common Mistakes / Gotchas

**1. Forgetting `buffered: true`**

If you register an observer after page load, metrics like LCP and FCP have already been recorded. Without `buffered: true`, you miss those early entries entirely. Always pass `buffered: true` unless you have a specific reason not to.

```ts
// ❌ Will miss LCP if registered after the paint
observer.observe({ type: "largest-contentful-paint" });

// ✅ Catches entries that already occurred
observer.observe({ type: "largest-contentful-paint", buffered: true });
```

**2. Not calling `disconnect()` on cleanup**

`PerformanceObserver` holds a reference to your callback. In a React component, if you don't call `observer.disconnect()` in the `useEffect` cleanup, you leak the observer across re-renders and navigations.

**3. Assuming `PerformanceObserver` is always available**

It's widely supported but not available in some server-side rendering contexts (Node.js, edge runtimes) or older browsers. Always guard with:

```ts
if (typeof PerformanceObserver !== "undefined") {
  // safe to use
}
```

<Callout type="warn">
  In Next.js App Router, any code that references `PerformanceObserver` must run
  inside a Client Component's `useEffect`. Importing it at the module level in a
  Server Component will throw a runtime error.
</Callout>

**4. Treating LCP as a single event**

The browser can emit multiple LCP candidates as the page loads (first a small image, then a larger hero image). The final LCP value is the _last_ entry before the user first interacts. Always store and overwrite, never just take the first entry.

**5. Confusing `startTime` and `duration`**

For paint metrics (LCP, FCP), the meaningful value is `startTime` — the time from navigation start to when the element painted. `duration` is `0` for these entry types. For `longtask` and `resource`, `duration` is the relevant measurement.

---

## Summary

`PerformanceObserver` is the standard browser API for monitoring real-user performance metrics asynchronously. It replaces manual polling of the performance timeline and powers tools like Lighthouse, web-vitals, and RUM platforms. Use `buffered: true` when observing paint and layout metrics so you don't miss early entries. Always disconnect the observer on cleanup to avoid memory leaks. In Next.js App Router, wrap all observer logic in a `"use client"` component inside `useEffect`. For production use, the `web-vitals` package is a thin, well-maintained abstraction that handles edge cases like LCP finalization automatically.
