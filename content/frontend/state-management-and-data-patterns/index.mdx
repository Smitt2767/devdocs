---
title: Overview
description: How state flows through an application — including the edge cases that cause subtle, hard-to-reproduce bugs in production UI.
---

## Overview

Most state management articles focus on which library to use. This section focuses on the underlying problems that all state management approaches have to solve: consistency, derivation, race conditions, and the boundary between server and client truth.

## What's covered

**Immutable Data Patterns** — Why mutating state directly causes missed updates and unpredictable re-renders, and how structural sharing makes immutable updates efficient.

**Memoization Pitfalls** — When `useMemo`, `useCallback`, and `React.memo` help, when they silently break due to unstable dependencies, and when they're not worth the complexity.

**Race Conditions in UI State** — How async operations that resolve out of order corrupt displayed state, and the patterns (abort signals, sequence IDs, reducers) that prevent it.

**Optimistic UI & Rollback Strategy** — Showing immediate feedback before a server response, and reverting cleanly when the server rejects the mutation.

**Offline Conflict Resolution** — Handling writes that occur while the user is offline and syncing them back to the server without data loss.

**Idempotent UI Actions** — Designing mutations that are safe to retry, and why this matters for network reliability and optimistic updates.

**Derived State vs Redundant State** — The single source of truth principle: when to compute state on the fly versus store it, and how redundant state causes sync bugs.

**State Boundaries** — How to decide what lives globally, what lives in a subtree, and what lives in the URL.

**URL as State** — Encoding UI state in the URL for shareability, bookmarkability, and server-side rendering compatibility.
