---
title: Overview
description: The network layer between your frontend and the server — HTTP evolution, browser security policies, API design, and authentication flows.
---

## Networking & Protocols

Frontend engineers interact with the network constantly but often treat it as a black box. Understanding the protocols, security boundaries, and authentication models at this layer is essential for building reliable, secure applications — and for diagnosing the class of bugs that only appear in production.

The section moves from the transport layer up through browser security policy, identity, API design, and finally resilience.

## What's covered

**HTTP/3 & QUIC** — How HTTP/3 eliminates head-of-line blocking by running over QUIC (UDP-based) instead of TCP, and what this means for connection setup latency and multiplexed streams.

**CORS & Preflight** — Why cross-origin requests are restricted, how the browser's preflight handshake works, and the exact `Access-Control-*` headers needed to configure it correctly.

**SameSite Cookie Modes** — `Strict`, `Lax`, and `None` — how each affects when cookies are sent in cross-site requests, and how this interacts with CSRF protection.

**Authentication Flows** — Session cookies, JWTs, OAuth 2.0, and OpenID Connect — how each flow works mechanically and where each is the right fit.

**API Paradigms** — REST, GraphQL, tRPC, and their trade-offs for type safety, client flexibility, caching, and team ergonomics.

**Rate Limiting on the Client** — Implementing exponential backoff, jitter, and request queuing to handle rate limit responses gracefully without hammering an API.

**WebSockets vs SSE vs Long Polling** — The three approaches to real-time server-to-client communication, with their respective trade-offs in connection overhead, browser support, and infrastructure complexity.
