---
title: Time Slicing
description: How React's concurrent renderer breaks rendering work into interruptible chunks to keep the UI responsive.
---

## Overview

Time slicing is a scheduling technique built into React's concurrent renderer that splits long rendering work into small units and spreads them across multiple frames. Instead of blocking the main thread until a render finishes, React yields control back to the browser between units of work, allowing higher-priority tasks — like responding to a keypress or animating a button — to run without delay.

Before concurrent React, a large render would hold the main thread hostage. The user could type into an input, but the browser couldn't paint the updated caret until the render completed. With time slicing, React pauses that render, lets the browser handle the input event, and then resumes.

<Callout type="info">
  Time slicing is not a feature you opt into with a single API. It is a property
  of concurrent rendering, which you unlock by using concurrent features like
  `useTransition`, `useDeferredValue`, and React 18's `createRoot`.
</Callout>

---

## How It Works

React's reconciler works on a virtual "fiber tree" — a linked list of work units, one per component. In legacy blocking mode, React walks the entire tree in one synchronous pass. In concurrent mode, React assigns each unit of work a **priority lane** and processes them in a loop that checks a deadline after each unit.

The deadline is based on the browser's frame budget (~16ms at 60fps). React uses the `MessageChannel` API internally (not `requestIdleCallback`) to schedule work. After each fiber is processed, React asks: _"Is there higher-priority work waiting, or has the frame deadline passed?"_ If yes, it pauses, yields to the browser, and schedules resumption.

This is why the same state update can behave differently depending on how it's triggered:

- A keystroke → high priority (urgent) → processes synchronously within the current frame
- A `startTransition` update → low priority (transition) → can be interrupted and resumed

React maintains a **work-in-progress tree** separate from the committed tree. Because the committed (displayed) tree is never mutated mid-render, React can safely abandon and restart the work-in-progress tree if a higher-priority update arrives.

---

## Code Examples

### Marking a state update as non-urgent with `useTransition`

```tsx
// app/search/page.tsx
"use client";

import { useState, useTransition } from "react";
import { SearchResults } from "./SearchResults";

export default function SearchPage() {
  const [query, setQuery] = useState("");
  const [displayedQuery, setDisplayedQuery] = useState("");
  const [isPending, startTransition] = useTransition();

  function handleChange(e: React.ChangeEvent<HTMLInputElement>) {
    // The input stays responsive because this update is urgent.
    setQuery(e.target.value);

    // The results re-render is wrapped in a transition — React can
    // interrupt and restart it if the user keeps typing.
    startTransition(() => {
      setDisplayedQuery(e.target.value);
    });
  }

  return (
    <div>
      <input
        value={query}
        onChange={handleChange}
        placeholder="Search products…"
      />
      {/* Show a visual hint while the transition is in progress */}
      {isPending && <span aria-live="polite">Updating results…</span>}
      <SearchResults query={displayedQuery} />
    </div>
  );
}
```

```tsx
// app/search/SearchResults.tsx
// This is a Server Component — fetching happens on the server.
// The client only receives the finished HTML, minimizing JS work.
import { getProducts } from "@/lib/db";

interface Props {
  query: string;
}

export async function SearchResults({ query }: Props) {
  const products = await getProducts(query); // real DB call

  if (products.length === 0) {
    return <p>No results for &quot;{query}&quot;.</p>;
  }

  return (
    <ul>
      {products.map((product) => (
        <li key={product.id}>{product.name}</li>
      ))}
    </ul>
  );
}
```

### Deferring a computed value with `useDeferredValue`

Use `useDeferredValue` when you receive a value from outside (e.g., props or context) and want the expensive component re-render to lag behind without controlling the update site.

```tsx
// app/dashboard/FilteredList.tsx
"use client";

import { useDeferredValue, memo } from "react";
import { ExpensiveChart } from "./ExpensiveChart";

interface Props {
  filter: string;
}

export function FilteredList({ filter }: Props) {
  // `deferredFilter` lags behind `filter` during transitions.
  // The stale chart stays visible until the new one is ready.
  const deferredFilter = useDeferredValue(filter);

  // When filter !== deferredFilter, the previous content is still shown.
  const isStale = filter !== deferredFilter;

  return (
    <div style={{ opacity: isStale ? 0.6 : 1, transition: "opacity 0.2s" }}>
      <ExpensiveChart filter={deferredFilter} />
    </div>
  );
}
```

<Callout type="warn">
  `useDeferredValue` does **not** debounce. It tells React to deprioritize
  re-renders caused by that value. The deferred render still runs as soon as the
  browser is idle — it just yields to urgent work first. Use a real debounce
  (`setTimeout` / `useDebounce`) if you want to limit the number of renders
  triggered.
</Callout>

---

## Real-World Use Case

**E-commerce faceted search.** A user is filtering a product catalog with checkboxes for size, color, and price range. Each checkbox click triggers a new query and re-renders a list of hundreds of product cards.

Without time slicing, checking a box blocks the thread while the list re-renders. The checkbox itself appears to lag. With `useTransition`, the checkbox state updates immediately (urgent), while the product list re-render is scheduled as a transition. The user sees the checkbox tick instantly, then the list fades in once React finishes the transition render.

```tsx
// app/catalog/Filters.tsx
"use client";

import { useTransition } from "react";
import { useRouter, usePathname, useSearchParams } from "next/navigation";

export function ColorFilter({ colors }: { colors: string[] }) {
  const router = useRouter();
  const pathname = usePathname();
  const searchParams = useSearchParams();
  const [isPending, startTransition] = useTransition();

  function applyFilter(color: string) {
    const params = new URLSearchParams(searchParams.toString());
    params.set("color", color);

    // URL navigation is a transition — the current page stays interactive
    // while the new segment streams in.
    startTransition(() => {
      router.push(`${pathname}?${params.toString()}`);
    });
  }

  return (
    <fieldset disabled={isPending}>
      <legend>Color</legend>
      {colors.map((color) => (
        <label key={color}>
          <input
            type="radio"
            name="color"
            value={color}
            onChange={() => applyFilter(color)}
          />
          {color}
        </label>
      ))}
    </fieldset>
  );
}
```

---

## Common Mistakes / Gotchas

**1. Wrapping urgent updates in a transition.**
Transitions are for non-urgent work. If you wrap a form submission or a navigation that the user is waiting on inside `startTransition`, the update will be deprioritized and feel sluggish. Reserve transitions for rendering work that can safely lag behind user input.

**2. Expecting `isPending` to reflect network latency.**
`isPending` from `useTransition` is `true` while React is processing the transition render, including any async Server Components or `Suspense` boundaries it causes to suspend. It is not a general loading flag for any fetch you initiate outside of React's rendering pipeline.

**3. Not memoizing expensive components paired with `useDeferredValue`.**
`useDeferredValue` only helps if the component receiving the deferred value skips re-rendering when the value hasn't changed. Wrap the expensive component in `memo` so React can bail out:

```tsx
import { memo } from "react";

// Without memo, React re-renders ExpensiveChart on every parent render
// regardless of whether deferredFilter changed.
export const ExpensiveChart = memo(function ExpensiveChart({
  filter,
}: {
  filter: string;
}) {
  // … heavy rendering logic
});
```

**4. Assuming concurrent features work without `createRoot`.**
Time slicing and all concurrent features require React 18's `createRoot`. Next.js App Router handles this for you, but if you have a custom React setup that still uses `ReactDOM.render`, none of this applies. Migrate to `createRoot`.

<Callout type="warn">
  React may render a transition update **multiple times** before committing it
  (if it is interrupted and restarted). Any side effects inside the render
  function that should only run once must be in a `useEffect` — not inline in
  the component body.
</Callout>

---

## Summary

Time slicing is the mechanism behind React's concurrent renderer that prevents long renders from blocking the main thread. React splits rendering work into interruptible units, yielding to the browser between them so high-priority tasks like user input are never delayed. You control which updates are low-priority using `useTransition` (when you own the state update) or `useDeferredValue` (when you only own the consuming component). The key mental model is the distinction between **urgent** updates, which run synchronously, and **transition** updates, which React can pause and restart. Pairing transitions with `memo` and `Suspense` gives you fine-grained control over when and how expensive re-renders appear to the user.
