---
title: Fiber Architecture
description: A deep dive into React's Fiber reconciler — how it enables incremental rendering, priority scheduling, and concurrent features.
---

## Overview

React Fiber is the internal reconciliation engine that has powered React since version 16. Before Fiber, React's reconciler worked synchronously: once it started rendering a tree, it couldn't stop until it was done. On large trees, this could freeze the main thread and drop frames.

Fiber rewrites the reconciler to be **incremental and interruptible**. Work is broken into small units called _fibers_, and React can pause, resume, abort, or reprioritize that work between frames. This is what makes Concurrent Mode features like `useTransition`, `Suspense`, and streaming SSR possible.

<Callout type="info">
  You don't interact with Fiber directly — it's an implementation detail. But
  understanding it will make concurrent features, render behavior, and
  performance debugging significantly clearer.
</Callout>

---

## How It Works

### The Fiber Node

Each React element (component, DOM node, fragment) gets a corresponding **fiber node** — a plain JavaScript object that acts as a unit of work. A fiber stores:

- The component type and its props
- A reference to its parent, child, and sibling fibers (forming a linked list tree)
- The output to be committed to the DOM
- Effect flags (did this fiber update? does it need a layout effect run?)
- A priority lane

```ts
// Simplified shape of an internal Fiber node (not public API)
type Fiber = {
  tag: number; // FunctionComponent, HostComponent, etc.
  type: any; // e.g. the actual function or 'div'
  key: string | null;
  pendingProps: any;
  memoizedProps: any;
  memoizedState: any; // hooks state is stored here as a linked list
  return: Fiber | null; // parent
  child: Fiber | null; // first child
  sibling: Fiber | null; // next sibling
  flags: Flags; // Update | Placement | Deletion, etc.
  lanes: Lanes; // priority
  alternate: Fiber | null; // double-buffer counterpart
};
```

### Double Buffering

React maintains **two fiber trees** at all times:

- The **current tree** — the one currently rendered on screen.
- The **work-in-progress (WIP) tree** — the tree being built for the next render.

Each fiber in the current tree has an `alternate` pointer to its counterpart in the WIP tree and vice versa. When React finishes building the WIP tree, it atomically swaps it to become the new current tree. This means the user never sees a half-rendered state.

### The Two Phases

Fiber work is split into two phases:

**1. Render phase (interruptible)**

React walks the fiber tree, calling your component functions, computing diffs, and building the WIP tree. This phase is **pure** — no DOM mutations, no side effects. Because it's pure, React can throw it away and restart if something higher-priority arrives (e.g., a user keypress).

**2. Commit phase (synchronous, non-interruptible)**

Once the WIP tree is complete, React commits it to the DOM in one synchronous pass. It then fires layout effects (`useLayoutEffect`), and schedules passive effects (`useEffect`) asynchronously. This phase cannot be interrupted because partial DOM mutations would produce a broken UI.

### Priority Lanes

React assigns every update a **lane** — a bitmask representing priority. Lanes include:

| Lane                | Example trigger                |
| ------------------- | ------------------------------ |
| SyncLane            | `ReactDOM.flushSync()`         |
| InputContinuousLane | `onChange`, scroll             |
| DefaultLane         | `setState` in an event handler |
| TransitionLane      | `startTransition()`            |
| IdleLane            | Background pre-rendering       |

The scheduler processes higher-priority lanes first. A `startTransition` update can be interrupted mid-render by an `InputContinuousLane` update — React discards the WIP tree and handles the urgent work first.

---

## Code Examples

### Observing Interruptible Rendering with `useTransition`

This example demonstrates the Fiber scheduler prioritizing urgent input over a heavy state update.

```tsx
// app/search/page.tsx
"use client";

import { useState, useTransition } from "react";
import { HeavyResultsList } from "@/components/heavy-results-list";

export default function SearchPage() {
  const [query, setQuery] = useState("");
  const [results, setResults] = useState<string[]>([]);
  const [isPending, startTransition] = useTransition();

  function handleChange(e: React.ChangeEvent<HTMLInputElement>) {
    const value = e.target.value;

    // Urgent: update the input immediately (SyncLane / InputContinuousLane)
    setQuery(value);

    // Non-urgent: defer the expensive results update (TransitionLane)
    // Fiber can interrupt this render if the user types again
    startTransition(() => {
      const filtered = generateResults(value); // expensive operation
      setResults(filtered);
    });
  }

  return (
    <div>
      <input
        value={query}
        onChange={handleChange}
        placeholder="Search..."
        className="border p-2 w-full"
      />
      {isPending && <p className="text-gray-400 text-sm">Updating results…</p>}
      <HeavyResultsList items={results} />
    </div>
  );
}

function generateResults(query: string): string[] {
  // Simulate a large computation
  return Array.from(
    { length: 10_000 },
    (_, i) => `${query} result ${i}`,
  ).filter((item) => item.includes(query));
}
```

```tsx
// components/heavy-results-list.tsx
// No 'use client' needed — this is a Client Component only because
// it's imported by one. It receives serializable props.

type Props = { items: string[] };

export function HeavyResultsList({ items }: Props) {
  return (
    <ul className="mt-4 space-y-1">
      {items.slice(0, 50).map((item) => (
        <li key={item} className="text-sm">
          {item}
        </li>
      ))}
    </ul>
  );
}
```

### Suspense Boundaries and Fiber

Fiber's work-in-progress mechanism powers Suspense. When a component throws a Promise, React catches it in the render phase, marks the fiber subtree as suspended, and renders the nearest `<Suspense>` fallback from the current (committed) tree — all without touching the DOM prematurely.

```tsx
// app/dashboard/page.tsx
import { Suspense } from "react";
import { UserProfile } from "@/components/user-profile";
import { ActivityFeed } from "@/components/activity-feed";

// Both children are Server Components that async-fetch their own data.
// Fiber handles the suspended states independently per subtree.
export default function DashboardPage() {
  return (
    <div className="grid grid-cols-2 gap-6">
      <Suspense fallback={<ProfileSkeleton />}>
        <UserProfile />
      </Suspense>
      <Suspense fallback={<FeedSkeleton />}>
        <ActivityFeed />
      </Suspense>
    </div>
  );
}

function ProfileSkeleton() {
  return <div className="animate-pulse h-32 bg-gray-200 rounded" />;
}

function FeedSkeleton() {
  return <div className="animate-pulse h-64 bg-gray-200 rounded" />;
}
```

```tsx
// components/user-profile.tsx
// Server Component — no 'use client'
async function fetchUser() {
  const res = await fetch("https://api.example.com/user/me", {
    next: { revalidate: 60 },
  });
  if (!res.ok) throw new Error("Failed to fetch user");
  return res.json() as Promise<{ name: string; avatar: string }>;
}

export async function UserProfile() {
  const user = await fetchUser();
  return (
    <div className="flex items-center gap-3">
      <img
        src={user.avatar}
        alt={user.name}
        className="w-10 h-10 rounded-full"
      />
      <span className="font-medium">{user.name}</span>
    </div>
  );
}
```

---

## Real-World Use Case

**E-commerce product filter page**

A product listing page has a sidebar with 20+ filter checkboxes (price, brand, rating, size). Each checkbox triggers a re-render that filters thousands of items and re-renders a large grid.

Without Fiber-aware code, rapid checkbox toggling causes the input to feel laggy because each update blocks the main thread while the grid re-renders.

Using `startTransition`, you mark the grid re-render as non-urgent. The Fiber scheduler allows React to interrupt that render if the user clicks another checkbox, discarding the stale WIP tree and starting fresh with the latest filter state. The checkboxes respond instantly; the grid catches up after.

This is only possible because Fiber's render phase is interruptible — the commit phase only fires once the correct final state is ready.

---

## Common Mistakes / Gotchas

### 1. Assuming renders are synchronous by default in Concurrent Mode

Once you opt into concurrent features (via `startTransition`, `useDeferredValue`, or the React 18 `createRoot` API — which Next.js App Router uses by default), renders are no longer guaranteed to be synchronous or uninterrupted. **Side effects in the render body can fire multiple times** if React restarts the render phase.

```tsx
// ❌ Side effect during render — dangerous in concurrent mode
export function BadComponent({ id }: { id: string }) {
  analytics.track("render", { id }); // may fire multiple times per commit!
  return <div>{id}</div>;
}

// ✅ Side effect in useEffect — fires once after commit
export function GoodComponent({ id }: { id: string }) {
  useEffect(() => {
    analytics.track("render", { id });
  }, [id]);
  return <div>{id}</div>;
}
```

### 2. Wrapping urgent updates in `startTransition`

`startTransition` marks updates as **interruptible and low priority**. If you accidentally wrap a user-facing state update (like controlled input value) in a transition, the input will feel broken — the UI won't update until React decides to commit the transition.

```tsx
// ❌ Input value update wrapped in transition — input lags noticeably
startTransition(() => {
  setInputValue(e.target.value);
});

// ✅ Input value is urgent; only defer the derived/expensive state
setInputValue(e.target.value); // urgent, outside transition
startTransition(() => {
  setFilteredItems(computeFilter(e.target.value)); // expensive, deferrable
});
```

### 3. Conflating the render phase with the commit phase

`useLayoutEffect` fires synchronously **during the commit phase**, which can't be interrupted. Expensive work here will block the browser. `useEffect` fires asynchronously after the commit and is safer for most side effects.

```tsx
// ❌ Expensive DOM measurement in useLayoutEffect blocks the commit phase
useLayoutEffect(() => {
  const result = expensiveLayoutCalculation(ref.current);
  setHeight(result);
}, []);

// ✅ Only use useLayoutEffect for synchronous DOM reads that must happen
// before the browser paints — e.g., reading scroll position to avoid flicker.
useLayoutEffect(() => {
  ref.current.scrollTop = savedScrollPosition; // fine: fast, layout-critical
}, []);
```

### 4. Misunderstanding `StrictMode` double-invocation

In development, React 18 with `StrictMode` intentionally **invokes the render phase twice** to surface impure renders (a direct consequence of Fiber's interruptible design — if a render can be restarted, it must be idempotent). This is dev-only and doesn't affect production.

<Callout type="warn">
  If you see state or effects running twice in development, this is `StrictMode`
  doing its job. Don't disable `StrictMode` to fix it — fix the impurity
  instead.
</Callout>

---

## Summary

React Fiber is the reconciliation engine that replaces the old synchronous stack reconciler with an interruptible, priority-aware system. Every React element maps to a fiber node in a linked-list tree, and React maintains two trees — current and work-in-progress — swapping them atomically on commit. Work is split into a pure, interruptible render phase and a synchronous commit phase, enabling Concurrent features like `startTransition` and `Suspense` to work correctly. Understanding Fiber explains why renders must be side-effect free, why `StrictMode` double-invokes renders in development, and how priority scheduling lets urgent updates preempt expensive background work.
