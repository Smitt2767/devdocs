---
title: Shadow DOM
description: How Shadow DOM encapsulates styles and DOM structure at the browser level, how Declarative Shadow DOM enables SSR, how adoptedStyleSheets share styles efficiently, and when to use it versus CSS Modules or scoped CSS.
---

## Overview

Shadow DOM is the browser's native encapsulation primitive. It lets you attach a separate, isolated DOM tree — the "shadow tree" — to any HTML element. Styles defined inside a shadow tree don't leak out to the document, and document styles don't leak in. The host element's children in the main DOM are slotted into the shadow tree via `<slot>` elements.

This is the technology behind native browser components like `<video>`, `<input type="range">`, and `<details>` — their internal DOM is a shadow tree you can partially inspect in DevTools. It's also the foundation of Web Components.

For most React applications, CSS Modules or Tailwind provide sufficient style scoping at lower complexity. Shadow DOM becomes the right choice when: you need true platform-level encapsulation (not naming conventions), you're building distributable Web Components that work across frameworks, or you need to embed a styled UI into a third-party host page without style interference in either direction.

---

## How It Works

### Attaching a Shadow Root

Any element can host a shadow tree. You call `element.attachShadow({ mode: "open" })` to create the shadow root, then add children to it:

```js
const host = document.querySelector(".card");
const shadow = host.attachShadow({ mode: "open" });

shadow.innerHTML = `
  <style>
    /* Only applies inside this shadow tree */
    :host { display: block; border-radius: 8px; padding: 1rem; }
    h2 { font-size: 1.25rem; }
  </style>
  <h2>Card Title</h2>
  <slot></slot>
`;
```

`mode: "open"` means the shadow root is accessible via `element.shadowRoot` from JavaScript outside the shadow tree. `mode: "closed"` makes it inaccessible — used in native browser elements to prevent external manipulation.

### Style Encapsulation Rules

**Inside → outside:** Styles defined inside a shadow tree don't affect the document. A `.card { background: red }` inside the shadow has no effect on `.card` elements in the document.

**Outside → inside:** Document styles don't apply inside the shadow tree. A global `h2 { color: blue }` in your app's CSS doesn't affect `h2` elements inside a shadow tree.

**Exceptions:**

- **CSS custom properties (`--var`)** inherit _through_ the shadow boundary. This is the intended theming API: you set `--color-primary` on the host, the shadow tree's styles read it.
- **Inherited properties** (`color`, `font-family`, `line-height`) inherit from the host element into the shadow tree's `:host` context.
- **`::part()` pseudo-element** allows external styles to target specific parts of a shadow tree that the component author has explicitly exposed.

### `<slot>` — Content Projection

Slots are placeholders in the shadow tree for content provided by the host's light DOM children:

```html
<!-- Shadow template -->
<div class="card">
  <div class="card-header">
    <slot name="title"></slot>
    <!-- named slot -->
  </div>
  <div class="card-body">
    <slot></slot>
    <!-- default slot: all unassigned children -->
  </div>
</div>
```

```html
<!-- Consumer -->
<my-card>
  <h2 slot="title">Product Name</h2>
  <!-- assigned to [name="title"] slot -->
  <p>Description goes here.</p>
  <!-- assigned to the default slot -->
</my-card>
```

Slotted content remains in the light DOM (it's part of the document's DOM tree) and is visually projected into the shadow tree's slot positions. CSS styles on slotted elements come from the document, not the shadow — the component author can target them with `::slotted()` but only at one level of depth.

---

## Code Examples

### Web Component with Shadow DOM

```ts
// components/ProductCard.ts — Web Component (no framework required)

class ProductCard extends HTMLElement {
  // Declare observed attributes — attributeChangedCallback fires for these
  static get observedAttributes() {
    return ["product-name", "price", "image-url"];
  }

  private shadow: ShadowRoot;

  constructor() {
    super();
    // Attach shadow root immediately in constructor
    this.shadow = this.attachShadow({ mode: "open" });
  }

  // Called when the element is added to the document
  connectedCallback() {
    this.render();
  }

  // Called when an observed attribute changes
  attributeChangedCallback() {
    this.render();
  }

  private render() {
    const name = this.getAttribute("product-name") ?? "";
    const price = this.getAttribute("price") ?? "";
    const imageUrl = this.getAttribute("image-url") ?? "";

    this.shadow.innerHTML = `
      <style>
        :host {
          display: block;
          border-radius: 0.5rem;
          overflow: hidden;
          box-shadow: 0 1px 3px rgb(0 0 0 / 0.1);
          /* Read CSS custom properties set by the host document for theming */
          background: var(--card-bg, #ffffff);
          color: var(--card-text, #0f172a);
          font-family: var(--font-sans, system-ui, sans-serif);
        }

        :host(:hover) {
          box-shadow: 0 4px 6px rgb(0 0 0 / 0.1);
        }

        img {
          width: 100%;
          aspect-ratio: 4 / 3;
          object-fit: cover;
        }

        .content { padding: 1rem; }
        .name    { font-size: 1rem; font-weight: 600; margin: 0 0 0.25rem; }
        .price   { font-size: 1.25rem; font-weight: 700; color: var(--color-primary, #3b82f6); }

        /* ::slotted targets direct children in the default slot */
        ::slotted(p) { font-size: 0.875rem; color: #64748b; margin: 0.5rem 0 0; }
      </style>

      <img src="${imageUrl}" alt="${name}" />
      <div class="content">
        <h2 class="name" part="name">${name}</h2>
        <p class="price" part="price">$${price}</p>
        <slot></slot>
      </div>
    `;
  }
}

// Register with the custom elements registry
customElements.define("product-card", ProductCard);
```

```html
<!-- Usage — works in any HTML, any framework -->
<product-card
  product-name="Wireless Headphones"
  price="129.99"
  image-url="/images/headphones.jpg"
>
  <p>Noise-cancelling, 30-hour battery life.</p>
</product-card>

<style>
  /* Theme via CSS custom properties — the intended external API */
  :root {
    --color-primary: #8b5cf6; /* purple brand */
    --card-bg: #f8fafc;
  }

  /* ::part() — target exposed parts directly from the outside */
  product-card::part(price) {
    font-size: 1.5rem; /* override price typography externally */
  }
</style>
```

---

### `adoptedStyleSheets` — Shared Stylesheets Without Duplication

When multiple shadow roots need the same styles (design tokens, base reset), `adoptedStyleSheets` shares a single `CSSStyleSheet` object across multiple shadow roots without duplicating the CSS text:

```ts
// lib/shared-styles.ts — single stylesheet instance shared across components

// CSSStyleSheet is the CSS Object Model representation of a stylesheet
const sharedSheet = new CSSStyleSheet();

// replaceSync populates the stylesheet synchronously
sharedSheet.replaceSync(`
  *, *::before, *::after {
    box-sizing: border-box;
  }

  :host {
    /* Inherit design tokens from the document */
    --color-primary:    var(--ds-color-primary, #3b82f6);
    --color-text:       var(--ds-color-text, #0f172a);
    --radius-md:        var(--ds-radius-md, 0.5rem);
    --font-sans:        var(--ds-font-sans, system-ui, sans-serif);
  }
`);

export { sharedSheet };
```

```ts
// components/BaseComponent.ts — adopts the shared stylesheet
import { sharedSheet } from "@/lib/shared-styles";

class BaseButton extends HTMLElement {
  private shadow: ShadowRoot;

  constructor() {
    super();
    this.shadow = this.attachShadow({ mode: "open" });

    // adoptedStyleSheets: the shadow root shares the CSSStyleSheet object.
    // No CSS duplication — all shadow roots referencing the same sheet
    // use one in-memory stylesheet, not copies.
    this.shadow.adoptedStyleSheets = [sharedSheet];
  }

  connectedCallback() {
    this.shadow.innerHTML = `
      <button part="button">
        <slot></slot>
      </button>
    `;

    // Additional component-specific styles (separate from shared)
    const componentSheet = new CSSStyleSheet();
    componentSheet.replaceSync(`
      button {
        background: var(--color-primary);
        color: white;
        border: none;
        border-radius: var(--radius-md);
        padding: 0.5rem 1rem;
        font-family: var(--font-sans);
        cursor: pointer;
        font-size: 0.875rem;
        font-weight: 500;
      }
      button:hover { filter: brightness(1.1); }
      button:focus-visible { outline: 2px solid var(--color-primary); outline-offset: 2px; }
    `);

    // Combine shared + component-specific stylesheets
    this.shadow.adoptedStyleSheets = [sharedSheet, componentSheet];
  }
}

customElements.define("ds-button", BaseButton);
```

---

### Declarative Shadow DOM — SSR-Compatible

Imperative Shadow DOM (`attachShadow()`) only works in the browser — it requires JavaScript to run. **Declarative Shadow DOM** uses a `<template shadowrootmode>` attribute to declare the shadow root in HTML itself, making it SSR-compatible:

```html
<!-- Server renders this HTML — no JavaScript required for the shadow root -->
<product-card>
  <template shadowrootmode="open">
    <style>
      :host {
        display: block;
        padding: 1rem;
        background: var(--card-bg, white);
      }
      h2 {
        font-size: 1.125rem;
        font-weight: 600;
      }
    </style>
    <h2 part="title">
      <slot name="title"></slot>
    </h2>
    <div class="body">
      <slot></slot>
    </div>
  </template>

  <!-- Light DOM children — slotted into the shadow tree -->
  <span slot="title">Wireless Headphones</span>
  <p>Noise-cancelling, 30-hour battery life.</p>
</product-card>
```

```tsx
// app/products/page.tsx — Next.js Server Component generating DSD
// Declarative Shadow DOM in JSX (requires suppressHydrationWarning on the template)
export async function ProductCard({ product }: { product: Product }) {
  return (
    <product-card>
      {/* @ts-expect-error — shadowrootmode is not in React's JSX types yet */}
      <template shadowrootmode="open" suppressHydrationWarning>
        <style>{`
          :host {
            display: block;
            border-radius: 0.5rem;
            background: var(--card-bg, white);
            box-shadow: 0 1px 3px rgb(0 0 0 / 0.1);
          }
          ::slotted(img) { width: 100%; aspect-ratio: 4/3; object-fit: cover; }
          .content { padding: 1rem; }
        `}</style>
        <slot name="image"></slot>
        <div className="content">
          <slot name="title"></slot>
          <slot name="price"></slot>
          <slot></slot>
        </div>
      </template>

      <img slot="image" src={product.imageUrl} alt={product.name} />
      <h2 slot="title">{product.name}</h2>
      <span slot="price">${product.price}</span>
    </product-card>
  );
}
```

---

### `::part()` — Exposing Shadow Internals for External Styling

`::part()` lets external CSS style specific elements inside a shadow tree that the component author has explicitly exposed via the `part` attribute:

```ts
// Shadow DOM — exposes internal elements via part attributes
this.shadow.innerHTML = `
  <style>
    /* Default internal styles */
    .container { display: flex; align-items: center; gap: 0.5rem; padding: 0.75rem; }
    .icon { width: 1.5rem; height: 1.5rem; }
    .label { font-weight: 500; }
    .badge { background: #dbeafe; color: #1e40af; padding: 2px 8px; border-radius: 9999px; font-size: 0.75rem; }
  </style>
  <div class="container">
    <span class="icon" part="icon">⚡</span>
    <span class="label" part="label"><slot></slot></span>
    <span class="badge" part="badge"></span>
  </div>
`;
```

```css
/* External CSS — styling the exposed parts */

/* Default appearance */
status-indicator::part(icon) {
  font-size: 1.25rem;
}
status-indicator::part(label) {
  font-family: var(--font-mono);
}

/* State-based styling of parts */
status-indicator[data-status="error"]::part(icon) {
  color: #dc2626;
}
status-indicator[data-status="success"]::part(icon) {
  color: #16a34a;
}
status-indicator[data-status="error"]::part(badge) {
  background: #fee2e2;
  color: #991b1b;
}
```

---

## Real-World Use Case

**Embedded third-party widget.** A SaaS company ships a customer feedback widget that's embedded on customer sites via a `<script>` tag. The widget renders inside a shadow root — the host site's CSS resets, font declarations, and layout rules have no effect on the widget, and the widget's CSS has no effect on the host site. This bidirectional isolation is impossible with CSS Modules or Tailwind (which only prevent the component's styles from leaking out, but don't prevent external styles from leaking in). The component publishes its theming surface via `::part()` and CSS custom properties — host sites can brand the widget without needing to know its internal structure.

**Design system published as Web Components.** A large organization has teams using React, Angular, Vue, and plain HTML. A Web Components-based design system works in all four without framework adapters. Styles are encapsulated natively. `adoptedStyleSheets` shares design token stylesheets across all component instances without duplication. `::part()` exposes a controlled styling API so teams can apply their brand overrides without breaking encapsulation.

---

## Common Mistakes / Gotchas

**1. Setting `innerHTML` with unescaped user data.**
Shadow DOM doesn't protect against XSS. If you render user-provided strings via `innerHTML`, you have an XSS vulnerability — shadow root or not. Always use `textContent` for user data:

```ts
// ❌ XSS vulnerability
shadow.innerHTML = `<div>${userInput}</div>`;

// ✅ Safe — textContent escapes HTML
const div = document.createElement("div");
div.textContent = userInput;
shadow.appendChild(div);
```

**2. Expecting `::slotted()` to work on nested elements.**
`::slotted(p)` targets direct slotted children. `::slotted(p span)` does not work — `::slotted()` only matches the top-level slotted element, not its descendants. For deeper styling, use CSS custom properties passed from outside, or accept that consumers style their slotted content with their own CSS.

**3. CSS resets and global fonts not applying inside shadow roots.**
Tailwind's `preflight`, `normalize.css`, `box-sizing: border-box` resets, and `font-family` set on `body` — none of these apply inside shadow trees. You must re-declare base styles inside each shadow root, or use `adoptedStyleSheets` to share them efficiently.

**4. `position: fixed` inside a shadow root is relative to the viewport — but transforms break it.**
`position: fixed` elements are positioned relative to the viewport, even inside a shadow root. However, if any ancestor of the shadow host has a `transform`, `filter`, or `will-change: transform`, the fixed-position element is positioned relative to that ancestor instead — the same behavior as in the light DOM.

**5. Declarative Shadow DOM requires a polyfill for older browsers.**
Declarative Shadow DOM (`<template shadowrootmode>`) is supported in Chrome 111+, Safari 16.4+, and Firefox 123+. For older browsers, a small JavaScript polyfill processes the templates imperatively after load. Always verify browser support requirements before using DSD in production SSR.

---

## Summary

Shadow DOM provides native browser-level style and DOM encapsulation. Styles inside a shadow tree don't leak out, and document styles don't leak in — making it the right choice for distributable Web Components and third-party embeds where bidirectional isolation is required. CSS custom properties and `::part()` are the intended external theming API. `adoptedStyleSheets` shares a single `CSSStyleSheet` object across multiple shadow roots without CSS duplication. Declarative Shadow DOM (`<template shadowrootmode="open">`) enables shadow roots in server-rendered HTML without JavaScript. For standard React applications, CSS Modules or Tailwind provide sufficient scoping at lower complexity — reach for Shadow DOM when you need true platform-level isolation or cross-framework compatibility.

---

## Interview Questions

**Q1. How does Shadow DOM style encapsulation work and what are its limits?**

Shadow DOM creates a style boundary at the shadow root. CSS rules defined inside the shadow tree (in `<style>` tags or `adoptedStyleSheets`) only match elements inside that same shadow root — they never match document elements. Document CSS rules only match document elements — they never match elements inside a shadow root. The limits: CSS custom properties (variables) inherit through the shadow boundary (intentionally — this is the theming API). Inherited CSS properties like `color`, `font-family`, and `line-height` also inherit from the host element into the shadow `:host`. And `::part()` pseudo-elements allow external CSS to explicitly target shadow internals that the component author exposes. Shadow DOM is not a security boundary — it prevents _accidental_ style collision, not _intentional_ CSS injection.

**Q2. What is `::part()` and why does it exist?**

`::part()` is a CSS pseudo-element that lets external stylesheets target specific elements inside a shadow tree that the component author has marked with a `part` attribute. Without `::part()`, the shadow boundary would make the component completely unstyable from outside — which would make it impossible to brand or theme. `::part()` solves this by giving component authors a controlled API: only elements explicitly marked with `part="name"` can be styled externally. Consumers style them with `my-component::part(name) { ... }`. This is a deliberate contract: the component exposes a surface area for external styling without exposing its full internal structure.

**Q3. What is Declarative Shadow DOM and why is it needed for SSR?**

Standard Shadow DOM is created imperatively via `element.attachShadow()` — a JavaScript API. This means shadow roots don't exist in the initial HTML sent by the server; they're created when JS runs on the client, causing content shifts and delayed rendering. Declarative Shadow DOM uses `<template shadowrootmode="open">` directly in HTML. When the browser's HTML parser encounters this, it creates the shadow root immediately during parsing — before any JavaScript runs. This makes shadow trees available in the initial paint, compatible with server-side rendering. It's now supported in all major modern browsers (Chrome 111+, Safari 16.4+, Firefox 123+).

**Q4. What is `adoptedStyleSheets` and what problem does it solve?**

Without `adoptedStyleSheets`, each shadow root that needs common styles (like a shared design token CSS file) must contain its own `<style>` block with a copy of those styles. With 50 component instances, you have 50 copies of the same CSS in memory and in the DOM. `adoptedStyleSheets` lets shadow roots (and the document) share a reference to a single `CSSStyleSheet` object. The stylesheet exists once in memory; all shadow roots using it share that single instance. This is both more memory-efficient and enables live updates — calling `sheet.replace()` immediately updates all adopting shadow roots and documents.

**Q5. When should you use Shadow DOM vs CSS Modules vs Tailwind for style scoping?**

CSS Modules and Tailwind handle _leaking out_: they scope your component's class names so they don't collide with other components' classes. They don't handle _leaking in_: document-level styles (CSS resets, global typography, third-party styles) can still affect your component's elements. Shadow DOM handles both directions: bidirectional encapsulation. Use Shadow DOM when: you're building a Web Component distributed to third-party sites (you have no control over the host page's CSS), you need cross-framework compatibility without framework adapters, or the component embeds in hostile styling environments. Use CSS Modules or Tailwind when: you're building within a single React application where you control the global CSS, need SSR-friendliness without polyfills, or want lower-complexity tooling.

**Q6. How do CSS custom properties work across the shadow boundary and why is this useful?**

CSS custom properties (variables) inherit through the shadow boundary just like other inherited CSS properties. If you set `--color-primary: #8b5cf6` on the `<body>` or a shadow host element, a `var(--color-primary)` inside the shadow tree resolves to that value. This is by design — it's the primary theming mechanism for Web Components. The component defines its internal styles using `var(--card-bg, white)` (with a fallback), and consumers theme the component by setting the custom property on the host: `product-card { --card-bg: #f8fafc; }`. This gives external code a clean, explicit API for theming (custom properties they set) while keeping internal implementation details (the actual class names and structure) fully encapsulated.
