---
title: Headless UI Pattern
description: How to separate component logic and accessibility from markup entirely — building reusable behavior that any consumer can render however they need.
---

## Overview

A headless component owns all the hard parts of a UI widget — state management, keyboard navigation, focus handling, and ARIA attributes — but renders nothing itself. The consumer provides the markup and styles. The headless component just makes everything work.

This is the architectural philosophy behind Radix UI, React Aria, Headless UI, Downshift, and React Table. Each library solves a genuinely difficult problem (an accessible combobox, a sortable data table, a focus-trapped dialog) and exposes the solution as pure behavior, decoupled from any visual opinion.

The contrast with compound components is important. A compound component shares state across cooperating pieces of markup that it defines — `<Tabs.Trigger>` renders a `<button>`, `<Tabs.Panel>` renders a `<div>`. A headless component defines no markup at all. The consumer owns every element. This makes headless components the right choice when visual rendering must vary across products or teams, but the logic must be consistent everywhere.

---

## How It Works

Headless components come in two forms, and understanding the distinction matters.

**Hook-based headless** — the component exposes a custom hook. The hook returns state values, event handlers, and pre-built prop objects (`getInputProps`, `getMenuProps`, `getLabelProps`). The consumer spreads those props onto whatever elements they choose. This is the modern approach — hooks compose better and don't introduce extra DOM nodes.

**Component-based headless (render props)** — the component wraps its children in a function call, passing state and handlers as arguments. The consumer destructures what they need and returns their own JSX. This predates hooks and is less common in new libraries, but you'll encounter it in older codebases and it remains useful in a narrow set of cases where the component needs to inject DOM structure (portals, event boundaries) alongside the logic.

In both forms, the contract is the same: the library owns the behavior, you own the pixels.

---

## Code Examples

### 1. Hook-based headless — `useDisclosure`

The simplest case: a hook that manages open/closed state and returns everything needed to wire up an accessible trigger and panel.

```tsx
// hooks/use-disclosure.ts
import { useState, useId, useCallback } from "react";

interface UseDisclosureReturn {
  isOpen: boolean;
  open: () => void;
  close: () => void;
  toggle: () => void;
  // Spread onto the trigger element (button, etc.)
  triggerProps: {
    onClick: () => void;
    "aria-expanded": boolean;
    "aria-controls": string;
  };
  // Spread onto the panel element (div, section, etc.)
  panelProps: {
    id: string;
    hidden: boolean;
  };
}

export function useDisclosure(defaultOpen = false): UseDisclosureReturn {
  const [isOpen, setIsOpen] = useState(defaultOpen);
  const panelId = useId();

  const open = useCallback(() => setIsOpen(true), []);
  const close = useCallback(() => setIsOpen(false), []);
  const toggle = useCallback(() => setIsOpen((prev) => !prev), []);

  return {
    isOpen,
    open,
    close,
    toggle,
    triggerProps: {
      onClick: toggle,
      "aria-expanded": isOpen,
      "aria-controls": panelId,
    },
    panelProps: {
      id: panelId,
      hidden: !isOpen,
    },
  };
}
```

```tsx
// Usage A: an FAQ accordion — consumer owns the full markup
"use client";

import { useDisclosure } from "@/hooks/use-disclosure";

interface FAQItemProps {
  question: string;
  answer: string;
}

export function FAQItem({ question, answer }: FAQItemProps) {
  const { isOpen, triggerProps, panelProps } = useDisclosure();

  return (
    <div className="border-b border-border py-4">
      <button
        className="flex w-full items-center justify-between text-left font-medium"
        {...triggerProps}
      >
        {question}
        {/* Consumer decides the icon — the hook doesn't care */}
        <span aria-hidden="true">{isOpen ? "−" : "+"}</span>
      </button>

      <div className="mt-3 text-sm text-muted-foreground" {...panelProps}>
        {answer}
      </div>
    </div>
  );
}
```

```tsx
// Usage B: a sidebar drawer — same hook, completely different markup
"use client";

import { useEffect } from "react";
import { useDisclosure } from "@/hooks/use-disclosure";

export function Sidebar() {
  const { isOpen, open, close, triggerProps, panelProps } = useDisclosure();

  // Close on Escape key — the hook owns state, the component owns behavior
  useEffect(() => {
    if (!isOpen) return;
    function handleKey(e: KeyboardEvent) {
      if (e.key === "Escape") close();
    }
    window.addEventListener("keydown", handleKey);
    return () => window.removeEventListener("keydown", handleKey);
  }, [isOpen, close]);

  return (
    <>
      <button className="hamburger-btn" {...triggerProps}>
        Menu
      </button>

      {/* Completely different DOM structure than the FAQ — same hook */}
      <aside
        className={`fixed inset-y-0 left-0 w-64 bg-background shadow-xl transition-transform ${
          isOpen ? "translate-x-0" : "-translate-x-full"
        }`}
        {...panelProps}
      >
        <nav>...</nav>
      </aside>

      {isOpen && (
        <div
          className="fixed inset-0 bg-black/40"
          onClick={close}
          aria-hidden="true"
        />
      )}
    </>
  );
}
```

The same 30 lines of hook logic powers two completely different components. Neither required the other to change.

---

### 2. Hook-based headless — `useCombobox`

A more complex example: a combobox (autocomplete input). This is where headless shines — keyboard navigation, ARIA, and filtering logic are genuinely hard. The hook owns all of it.

```tsx
// hooks/use-combobox.ts
"use client";

import {
  useState,
  useRef,
  useId,
  useCallback,
  type KeyboardEvent,
} from "react";

interface UseComboboxOptions<T> {
  items: T[];
  itemToString: (item: T) => string;
  onSelect?: (item: T) => void;
}

export function useCombobox<T>({
  items,
  itemToString,
  onSelect,
}: UseComboboxOptions<T>) {
  const [inputValue, setInputValue] = useState("");
  const [isOpen, setIsOpen] = useState(false);
  const [highlightedIndex, setHighlightedIndex] = useState(-1);

  const inputRef = useRef<HTMLInputElement>(null);
  const listId = useId();
  const inputId = useId();

  const filtered = items.filter((item) =>
    itemToString(item).toLowerCase().includes(inputValue.toLowerCase()),
  );

  const selectItem = useCallback(
    (item: T) => {
      setInputValue(itemToString(item));
      setIsOpen(false);
      setHighlightedIndex(-1);
      onSelect?.(item);
      inputRef.current?.focus();
    },
    [itemToString, onSelect],
  );

  function handleKeyDown(e: KeyboardEvent<HTMLInputElement>) {
    if (!isOpen) {
      if (e.key === "ArrowDown") setIsOpen(true);
      return;
    }

    if (e.key === "ArrowDown") {
      e.preventDefault();
      setHighlightedIndex((i) => Math.min(i + 1, filtered.length - 1));
    } else if (e.key === "ArrowUp") {
      e.preventDefault();
      setHighlightedIndex((i) => Math.max(i - 1, 0));
    } else if (e.key === "Enter" && highlightedIndex >= 0) {
      e.preventDefault();
      selectItem(filtered[highlightedIndex]);
    } else if (e.key === "Escape") {
      setIsOpen(false);
      setHighlightedIndex(-1);
    }
  }

  return {
    isOpen,
    filtered,
    highlightedIndex,
    selectItem,
    // Pre-built prop getters — spread onto elements
    getInputProps: () => ({
      ref: inputRef,
      id: inputId,
      value: inputValue,
      role: "combobox" as const,
      "aria-expanded": isOpen,
      "aria-controls": listId,
      "aria-autocomplete": "list" as const,
      onChange: (e: React.ChangeEvent<HTMLInputElement>) => {
        setInputValue(e.target.value);
        setIsOpen(true);
        setHighlightedIndex(-1);
      },
      onFocus: () => setIsOpen(true),
      onBlur: () => setTimeout(() => setIsOpen(false), 150),
      onKeyDown: handleKeyDown,
    }),
    getMenuProps: () => ({
      id: listId,
      role: "listbox" as const,
    }),
    getItemProps: (item: T, index: number) => ({
      role: "option" as const,
      "aria-selected": index === highlightedIndex,
      onMouseDown: (e: React.MouseEvent) => e.preventDefault(), // prevent input blur
      onClick: () => selectItem(item),
    }),
  };
}
```

```tsx
// components/country-selector.tsx
// Consumer owns every pixel — the hook owns all the behavior
"use client";

import { useCombobox } from "@/hooks/use-combobox";

const countries = [
  { code: "US", name: "United States" },
  { code: "IN", name: "India" },
  { code: "DE", name: "Germany" },
  { code: "JP", name: "Japan" },
  { code: "BR", name: "Brazil" },
];

export function CountrySelector() {
  const {
    isOpen,
    filtered,
    highlightedIndex,
    getInputProps,
    getMenuProps,
    getItemProps,
  } = useCombobox({
    items: countries,
    itemToString: (c) => c.name,
    onSelect: (c) => console.log("Selected:", c.code),
  });

  return (
    <div className="relative w-72">
      <label htmlFor="country-input" className="mb-1 block text-sm font-medium">
        Country
      </label>

      <input
        id="country-input"
        className="w-full rounded-md border border-input px-3 py-2 text-sm"
        placeholder="Search countries..."
        {...getInputProps()}
      />

      {isOpen && filtered.length > 0 && (
        <ul
          className="absolute z-10 mt-1 w-full rounded-md border border-border bg-background shadow-md"
          {...getMenuProps()}
        >
          {filtered.map((country, index) => (
            <li
              key={country.code}
              className={`cursor-pointer px-3 py-2 text-sm ${
                index === highlightedIndex
                  ? "bg-accent text-accent-foreground"
                  : "hover:bg-muted"
              }`}
              {...getItemProps(country, index)}
            >
              {country.name}
            </li>
          ))}
        </ul>
      )}
    </div>
  );
}
```

The keyboard navigation, ARIA wiring, and filtering are entirely in the hook. The component is just markup and Tailwind classes. Swap the styling, change the element types, add an icon — none of it touches the hook.

---

### 3. When render props still make sense

Hooks replaced render props for most use cases, but there's one scenario where the render prop form still wins: when the headless component needs to inject DOM structure alongside the logic — specifically, a portal for a floating element that must escape the current stacking context.

```tsx
// components/tooltip/index.tsx
"use client";

import { useState, useRef, useId, createPortal, type ReactNode } from "react";

interface TooltipRenderArgs {
  isVisible: boolean;
  triggerProps: {
    onMouseEnter: () => void;
    onMouseLeave: () => void;
    onFocus: () => void;
    onBlur: () => void;
    "aria-describedby": string;
  };
}

interface TooltipProps {
  content: string;
  children: (args: TooltipRenderArgs) => ReactNode;
}

export function Tooltip({ content, children }: TooltipProps) {
  const [isVisible, setIsVisible] = useState(false);
  const triggerRef = useRef<HTMLElement | null>(null);
  const tooltipId = useId();

  const show = () => setIsVisible(true);
  const hide = () => setIsVisible(false);

  return (
    <>
      {children({
        isVisible,
        triggerProps: {
          onMouseEnter: show,
          onMouseLeave: hide,
          onFocus: show,
          onBlur: hide,
          "aria-describedby": tooltipId,
        },
      })}

      {/* Portal: renders outside the current stacking context */}
      {isVisible &&
        createPortal(
          <div
            id={tooltipId}
            role="tooltip"
            className="fixed z-50 rounded bg-foreground px-2 py-1 text-xs text-background shadow"
          >
            {content}
          </div>,
          document.body,
        )}
    </>
  );
}
```

```tsx
// Usage — consumer owns the trigger element entirely
import { Tooltip } from "@/components/tooltip";

export function DeleteButton() {
  return (
    <Tooltip content="Permanently delete this record">
      {({ triggerProps }) => (
        <button
          className="rounded bg-destructive px-3 py-1.5 text-sm text-white"
          {...triggerProps}
        >
          Delete
        </button>
      )}
    </Tooltip>
  );
}
```

The render prop is justified here because the `Tooltip` needs to render the portal (a DOM element outside the consumer's tree) as part of its own output — not something a hook alone can do cleanly.

---

## Real-World Use Case

Your company ships three products: a B2B dashboard, a consumer mobile web app, and an internal admin tool. All three need a `<Select>` component with keyboard navigation, searchable options, grouped items, and full ARIA compliance.

The B2B dashboard uses Tailwind with a dense, compact design. The consumer app uses large touch targets and a bottom-sheet presentation on mobile. The admin tool uses an older design system with completely different CSS conventions.

Without headless components, you'd build three separate selects — or a single one with an unmaintainable pile of props controlling every visual variation.

With a headless `useSelect` hook, you build the keyboard navigation, ARIA management, and filtering once. Each product team wraps it in their own markup. The hook's behavior is consistent everywhere. When a keyboard navigation bug is fixed in the hook, all three products get the fix instantly.

---

## Common Mistakes / Gotchas

**1. Building hooks that know too much about the DOM**

A headless hook should return state and handlers — not refs to DOM nodes it creates itself. The consumer should pass in refs or attach handlers to their own elements. If your hook calls `document.querySelector` internally, it's no longer truly headless.

**2. Not using `useCallback` on returned functions**

If your hook returns new function references on every render (handlers, selectors), consumers that spread those into `useEffect` dependency arrays or pass them to memoized children will see unnecessary re-renders. Wrap returned callbacks in `useCallback`.

```ts
// ❌ New function reference every render
return {
  toggle: () => setIsOpen((prev) => !prev),
};

// ✅ Stable reference
const toggle = useCallback(() => setIsOpen((prev) => !prev), []);
return { toggle };
```

**3. Reaching for render props when a hook suffices**

If the headless component renders no DOM of its own (no portals, no event capture boundaries), it should be a hook, not a render prop component. Render props add a wrapper call and make the JSX harder to read for no benefit. The rule: if it returns `<>{children(state)}</>` with no DOM output, it's a hook waiting to happen.

**4. Not handling `onBlur` timing with `setTimeout`**

When a user clicks a list item in a combobox, the input fires `onBlur` before the item's `onClick`. Without a small `setTimeout` delay on the blur handler, the list closes and the click never lands. This is a near-universal gotcha in headless floating elements.

```ts
// Without the delay, the menu closes before onClick fires
onBlur: () => setTimeout(() => setIsOpen(false), 150),
```

**5. Forgetting that hooks can't be used in Server Components**

Headless hooks use `useState`, `useRef`, and `useId` — they're inherently client-side. Any component that calls a headless hook must be marked `'use client'`. The hook itself doesn't need the directive, but its consumers do.

<Callout type="info">
  You don't need to build headless components from scratch for common widgets.
  Radix UI Primitives and React Aria cover most of the hard cases (dialogs,
  tooltips, comboboxes, menus) with battle-tested keyboard and ARIA
  implementations. Build your own headless hooks for domain-specific logic that
  no library covers.
</Callout>

---

## Summary

Headless components separate behavior from markup by owning state, keyboard navigation, and accessibility attributes while rendering nothing themselves. Hook-based headless is the modern default — the hook returns prop getter functions that consumers spread onto their own elements, keeping the library out of the DOM entirely. Render props remain useful when the headless component needs to inject its own DOM (portals, event capture boundaries) alongside the logic. The pattern's core value is reuse without visual constraints: the same keyboard navigation and ARIA logic powers a compact dropdown in one product and a full-screen sheet in another. Use `useCallback` on all returned handlers for stable references, handle `onBlur` timing carefully in floating elements, and reach for Radix UI or React Aria before building your own for standard widgets.
