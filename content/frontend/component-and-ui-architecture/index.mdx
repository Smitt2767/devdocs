---
title: Overview
description: Patterns and mechanisms for structuring the UI layer — from component boundaries and server/client composition to micro-frontends and isolation primitives.
---

## Component & UI Architecture

This section covers how to structure the UI layer at a system level. Individual components are the unit of composition, but the decisions that matter most are about boundaries — where server work ends, where client interactivity begins, how errors are contained, and how large teams own independent UI surfaces.

## What's covered

**Server Components** — React's model for components that run only on the server, with no JavaScript sent to the client. Covers the server/client boundary, composition patterns, and when to reach for `'use client'`.

**Suspense Boundaries** — How to declaratively handle async rendering with loading states, and how boundaries interact with streaming SSR and data fetching.

**Error Boundaries** — Isolating runtime errors so a single component failure doesn't crash the entire UI tree.

**Edge Rendering** — Running server logic at the CDN edge for lower latency, and what constraints that introduces.

**Micro-frontend Orchestration** — How independently deployed frontend applications compose into a single UI — routing, shared state, and dependency isolation.

**Shadow DOM** — The browser's native encapsulation primitive, how it isolates styles and DOM, and when to use it versus CSS Modules or other scoping approaches.

**Compound Components** — How to build flexible, composable APIs using React Context to share implicit state across a cooperating set of components — the pattern behind tabs, accordions, and every serious UI library.

**Headless UI Pattern** — How to separate component logic, keyboard navigation, and accessibility from markup entirely — building reusable behavior that any consumer can render however they need.
