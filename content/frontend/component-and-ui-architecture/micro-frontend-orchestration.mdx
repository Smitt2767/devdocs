---
title: Micro-frontend Orchestration
description: How independently deployed frontend applications compose into a single UI — Module Federation v2 mechanics, shared dependency management, cross-app state and routing, and the organizational tradeoffs that make or break the pattern.
---

## Overview

Micro-frontends extend the microservices model to the UI layer. Instead of one frontend monolith, you split the application into independently developed, deployed, and owned pieces — each owned by a different team — and compose them into a single product at runtime or build time.

The payoff is organizational: Team A (Checkout) can ship independently of Team B (Catalog) with no coordination required. The cost is real: runtime composition introduces latency, shared dependency management is genuinely complex, and getting cross-application communication wrong produces a fragmented, inconsistent UX.

Micro-frontends are not always the right answer. For small teams or single-product organizations, a well-structured monorepo is simpler, faster, and avoids the orchestration complexity entirely. The right time to reach for micro-frontends is when independent deployment velocity across multiple teams with independent release schedules is a concrete, measured pain — not a hypothetical future concern.

---

## How It Works

### Three Composition Strategies

**Build-time composition** — each micro-frontend publishes to an npm registry. The shell application installs them as dependencies and bundles everything together. Teams are no longer independently deployable — any update requires a shell rebuild and redeploy. Useful primarily as an organizational boundary without runtime complexity.

**Server-side composition** — an edge or server layer assembles HTML fragments from multiple upstream services (via Edge Side Includes, an API gateway, or a dedicated composition layer) before delivering to the browser. Teams deploy their fragments to their own servers; the composition layer aggregates them. Fast initial render, good for SEO-sensitive pages. Requires server infrastructure for each fragment and makes client-side shared state harder to coordinate.

**Client-side composition via Module Federation (most common)** — a host ("shell") application loads remote JavaScript modules from other teams' deployments at runtime. Each remote exposes components or entire pages. The host fetches them on demand from their CDN URLs. This is what enables true independent deployability: Team A can update and redeploy their remote and all users of the shell get the new version on next load — no shell redeploy required.

### Module Federation v2 Mechanics

Webpack 5's Module Federation (also available for Vite via `@originjs/vite-plugin-federation` and `@module-federation/vite`) lets applications share code at runtime:

```
Host (Shell App)                   Remote (Catalog Team)
  Knows about remotes at build       Exposes:
  time, resolves at runtime          - ProductCard component
                                     - ProductList page
  At runtime:
  1. Fetches remoteEntry.js          Remote deploys to:
     from Catalog CDN                https://catalog.cdn.example.com
  2. Loads the module graph          remoteEntry.js contains the manifest
  3. Renders the component           of exposed modules + chunk URLs
```

**Shared dependencies** are the critical configuration: if both the shell and catalog remote bundle their own React, the user downloads React twice and — worse — has two React instances running simultaneously (which breaks hooks). The `shared` configuration declares singletons:

```js
// Shell's Module Federation config
shared: {
  react: {
    singleton: true,       // only one instance loaded
    requiredVersion: "^19.0.0",
    eager: true,           // include in the shell's initial bundle (not lazy)
  },
  "react-dom": {
    singleton: true,
    requiredVersion: "^19.0.0",
    eager: true,
  },
  // Design system — shared, but not singleton (each remote can use its own version)
  "@acme/design-system": {
    singleton: false,
    requiredVersion: "^2.0.0",
  },
}
```

---

## Code Examples

### Shell Application — Module Federation Host

```js
// webpack.config.js (shell / host app)
const { ModuleFederationPlugin } = require("@module-federation/webpack");

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: "shell",
      remotes: {
        // These URLs are resolved at runtime — each team controls their own CDN
        // In production: process.env.CATALOG_URL, etc. (configured per environment)
        catalog: "catalog@https://catalog.cdn.example.com/remoteEntry.js",
        checkout: "checkout@https://checkout.cdn.example.com/remoteEntry.js",
        account: "account@https://account.cdn.example.com/remoteEntry.js",
      },
      shared: {
        react: { singleton: true, requiredVersion: "^19.0.0", eager: true },
        "react-dom": {
          singleton: true,
          requiredVersion: "^19.0.0",
          eager: true,
        },
        "react-router-dom": { singleton: true, requiredVersion: "^6.0.0" },
      },
    }),
  ],
};
```

```tsx
// app/Router.tsx — Shell application routing
import React, { Suspense, lazy } from "react";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import { ErrorBoundary } from "@/components/ErrorBoundary";
import { ShellHeader } from "@/components/ShellHeader";
import { PageSkeleton } from "@/components/PageSkeleton";

// Lazy load from remote — resolves at runtime from the remote's CDN
// TypeScript: declare the remote module types in a .d.ts file
const CatalogPage = lazy(() => import("catalog/CatalogPage"));
const ProductPage = lazy(() => import("catalog/ProductPage"));
const CheckoutPage = lazy(() => import("checkout/CheckoutPage"));
const AccountPage = lazy(() => import("account/AccountPage"));

export function AppRouter() {
  return (
    <BrowserRouter>
      <ShellHeader />
      <main>
        <Routes>
          <Route
            path="/catalog/*"
            element={
              // Each remote gets its own Error + Suspense boundaries
              // so a failing remote doesn't crash the whole shell
              <ErrorBoundary>
                <Suspense fallback={<PageSkeleton />}>
                  <CatalogPage />
                </Suspense>
              </ErrorBoundary>
            }
          />
          <Route
            path="/products/:id"
            element={
              <ErrorBoundary>
                <Suspense fallback={<PageSkeleton />}>
                  <ProductPage />
                </Suspense>
              </ErrorBoundary>
            }
          />
          <Route
            path="/checkout/*"
            element={
              <ErrorBoundary>
                <Suspense fallback={<PageSkeleton />}>
                  <CheckoutPage />
                </Suspense>
              </ErrorBoundary>
            }
          />
          <Route
            path="/account/*"
            element={
              <ErrorBoundary>
                <Suspense fallback={<PageSkeleton />}>
                  <AccountPage />
                </Suspense>
              </ErrorBoundary>
            }
          />
        </Routes>
      </main>
    </BrowserRouter>
  );
}
```

---

### Remote Application — Module Federation Exposes

```js
// webpack.config.js (catalog team's remote app)
const { ModuleFederationPlugin } = require("@module-federation/webpack");

module.exports = {
  output: {
    // publicPath must be the actual CDN URL where this remote is deployed
    // The shell uses this URL to resolve chunk URLs from the remoteEntry manifest
    publicPath: "https://catalog.cdn.example.com/",
    uniqueName: "catalog", // unique name to prevent variable collisions
  },
  plugins: [
    new ModuleFederationPlugin({
      name: "catalog",
      filename: "remoteEntry.js", // manifest file the shell fetches
      exposes: {
        // What this remote makes available to consumers
        // Key: import path consumers use — import("catalog/CatalogPage")
        // Value: local file path in this repository
        "./CatalogPage": "./src/pages/CatalogPage",
        "./ProductPage": "./src/pages/ProductPage",
        "./ProductCard": "./src/components/ProductCard",
      },
      shared: {
        react: { singleton: true, requiredVersion: "^19.0.0" },
        "react-dom": { singleton: true, requiredVersion: "^19.0.0" },
        "react-router-dom": { singleton: true, requiredVersion: "^6.0.0" },
      },
    }),
  ],
};
```

---

### Cross-App State — Custom Events (The Decoupled Pattern)

Remotes should not import from each other — that creates coupling and breaks independent deployability. Cross-application communication uses browser-native custom events as a pub/sub bus:

```ts
// lib/event-bus.ts — shared event contract (published as an npm package)
// Both shell and remotes install this package to ensure type safety

export type AppEvents = {
  "cart:add": { productId: string; quantity: number; price: number };
  "cart:remove": { productId: string };
  "cart:cleared": Record<string, never>;
  "user:auth-change": { userId: string | null; role: string | null };
  "nav:route-change": { path: string; params?: Record<string, string> };
};

type EventName = keyof AppEvents;

export const eventBus = {
  emit<E extends EventName>(event: E, detail: AppEvents[E]): void {
    window.dispatchEvent(
      new CustomEvent(event, {
        detail,
        bubbles: true, // bubbles through the DOM — catchable anywhere
        composed: true, // crosses Shadow DOM boundaries
      }),
    );
  },

  on<E extends EventName>(
    event: E,
    handler: (detail: AppEvents[E]) => void,
  ): () => void {
    function listener(e: Event) {
      handler((e as CustomEvent<AppEvents[E]>).detail);
    }
    window.addEventListener(event, listener);
    // Returns unsubscribe function for cleanup
    return () => window.removeEventListener(event, listener);
  },
};
```

```tsx
// In the Catalog remote — emit when user adds to cart
import { eventBus } from "@acme/event-bus";

function AddToCartButton({ product }: { product: Product }) {
  function handleClick() {
    eventBus.emit("cart:add", {
      productId: product.id,
      quantity: 1,
      price: product.price,
    });
  }
  return <button onClick={handleClick}>Add to Cart</button>;
}
```

```tsx
// In the Shell — listen for cart events and update global cart state
import { useEffect } from "react";
import { eventBus } from "@acme/event-bus";
import { useCartStore } from "@/stores/cart";

export function CartSync() {
  const addItem = useCartStore((s) => s.addItem);
  const removeItem = useCartStore((s) => s.removeItem);
  const clear = useCartStore((s) => s.clear);

  useEffect(() => {
    const unsubscribeAdd = eventBus.on("cart:add", (d) => addItem(d));
    const unsubscribeRemove = eventBus.on("cart:remove", (d) =>
      removeItem(d.productId),
    );
    const unsubscribeClear = eventBus.on("cart:cleared", () => clear());

    return () => {
      unsubscribeAdd();
      unsubscribeRemove();
      unsubscribeClear();
    };
  }, [addItem, removeItem, clear]);

  return null; // purely a synchronization component
}
```

---

### TypeScript Module Declarations for Remotes

TypeScript doesn't know about remote modules at build time. Declare them:

```ts
// types/remotes.d.ts — add to tsconfig "include"

// Catalog remote
declare module "catalog/CatalogPage" {
  const CatalogPage: React.ComponentType<{ initialCategory?: string }>;
  export default CatalogPage;
}

declare module "catalog/ProductPage" {
  interface ProductPageProps {
    productId: string;
  }
  const ProductPage: React.ComponentType<ProductPageProps>;
  export default ProductPage;
}

declare module "catalog/ProductCard" {
  interface ProductCardProps {
    product: { id: string; name: string; price: number; imageUrl: string };
  }
  const ProductCard: React.ComponentType<ProductCardProps>;
  export default ProductCard;
}

// Checkout remote
declare module "checkout/CheckoutPage" {
  const CheckoutPage: React.ComponentType;
  export default CheckoutPage;
}
```

---

### Version Mismatch Handling

When remotes have different React versions (major version mismatches), `singleton: true` means the first-loaded version wins — which can break the later-loaded remote:

```ts
// Shell's webpack config — version negotiation
shared: {
  react: {
    singleton: true,
    // requiredVersion: the version range this app needs
    // strictVersion: true — throw if the loaded version doesn't satisfy the range
    requiredVersion: ">=18.0.0",
    strictVersion: false, // warn but don't throw on minor mismatches
    eager: true,
  },
}
```

For major version mismatches (React 18 vs React 19), the teams need to coordinate upgrades. The practical approach: establish a **platform contract** — a document specifying the minimum/maximum version of each shared singleton. Teams sign off on upgrades through a lightweight RFC process before deploying.

---

## Real-World Use Case

**Enterprise SaaS platform with 6 independent product teams.** Each team (Analytics, CRM, Billing, Reporting, Settings, Admin) deploys on their own cadence — 2–5 times per week. With a monolith, a bug in Billing's new feature delayed the entire platform release. With micro-frontends: each team deploys their remote independently. The shell is a thin routing layer. Shared dependencies (React, the design system, React Router) are configured as singletons. Cross-team communication (e.g., CRM notifying Analytics of a new contact) uses the custom event bus.

The platform contract defines: React 19 minimum, design system `^3.0.0`. Teams can upgrade patch and minor versions autonomously; major version upgrades require coordination via RFC. An integration test environment where all remotes are assembled runs nightly CI against the shell — catching cross-team integration failures before they reach production.

---

## Common Mistakes / Gotchas

**1. Not configuring `singleton: true` for React.**
Two React instances in the same page causes hooks to fail with cryptic errors ("Invalid hook call"). Module Federation's `singleton: true` ensures only one React is loaded. Make it `eager: true` in the shell to ensure it's available before any remote loads.

**2. Remote URLs hardcoded instead of environment-variable-driven.**
Hardcoding `https://catalog.cdn.example.com/remoteEntry.js` in the shell's webpack config means changing the catalog URL requires a shell rebuild and redeploy. Configure remote URLs via environment variables so deployments across environments (staging, production) don't require shell redeployment.

**3. Sharing state by importing a store across remote boundaries.**
Importing Zustand or Redux from another remote creates a direct code dependency and breaks independent deployability. Use the custom event bus for cross-remote communication. The event bus contract is versioned and published as a shared npm package — both sides depend on the types, not on each other's implementation.

**4. Not wrapping each remote in an Error Boundary.**
A runtime error in the Checkout remote loading or rendering must not crash the Catalog or Account sections. Each remote's entry point in the shell's router must have its own Error Boundary so failures are isolated.

**5. Missing the integration test gap.**
Each team's CI only tests their remote in isolation. When Team A changes a prop name in an exposed component, Team B's usage of that component breaks — but neither team's CI catches it. A nightly integration environment that assembles all current remotes in the shell catches these cross-team regressions before they reach production.

**6. Using micro-frontends when a monorepo would suffice.**
Micro-frontends solve an organizational problem (independent deployment). If your team is small enough that one repository and one deployment pipeline is manageable, a monorepo with shared packages is significantly simpler. The operational overhead of Module Federation configuration, version coordination, integration testing, and event bus design is only worth it when independent deployment velocity is a concrete, measured need.

---

## Summary

Micro-frontend orchestration composes independently deployed frontend applications into a single user-facing product. Module Federation (Webpack 5 / Vite) is the primary mechanism for client-side composition, enabling remotes to expose components loaded at runtime by a shell without shared build steps. Shared dependencies configured as `singleton: true` prevent the multiple-React-instances problem. Cross-remote communication should use browser custom events — not direct imports or shared stores — to maintain decoupling. Each remote in the shell's router needs its own Error Boundary and Suspense boundary. Version coordination requires a platform contract specifying allowed version ranges for shared singletons. The pattern is worth the complexity only when independent deployment velocity across multiple teams is a real, felt need — not a theoretical future concern.

---

## Interview Questions

**Q1. What is the multiple React instances problem and how does Module Federation's `singleton` option prevent it?**

React hooks use module-level state to track the current render context. If two separate React instances are loaded (e.g., shell and remote each bundle their own React), they each have independent module-level state. When a component from one React instance tries to use a hook registered in the other instance's context, it throws "Invalid hook call." `singleton: true` in Module Federation's shared config tells the federation runtime: load React exactly once, from whoever loads it first. All modules — shell and remotes — use that single instance. `eager: true` in the shell ensures React is in the shell's initial bundle and is available before any remote attempts to load.

**Q2. How does Module Federation resolve modules at runtime and what is `remoteEntry.js`?**

When the shell builds, it knows the remote URLs but doesn't bundle the remote code. At runtime, when the shell first needs a remote module (e.g., when the user navigates to `/catalog`), it fetches `remoteEntry.js` from the catalog's CDN URL. This file is the federation manifest — it describes which modules the remote exposes, the URLs of their code chunks, and the shared dependencies the remote needs. The shell's federation runtime reads this manifest, downloads only the chunks needed for the requested module, resolves shared dependencies (reusing already-loaded ones), and returns the module. The result: a lazy-loaded, dependency-deduplicated module that was deployed independently.

**Q3. Why should remotes communicate via custom events rather than shared state stores?**

Direct imports between remotes create coupling: the shell would need to know about Catalog's Zustand store structure, Catalog would need to import types from Checkout, etc. Any schema change to the store requires coordinating updates across multiple remotes — defeating independent deployability. Custom events (browser `CustomEvent` API) decouple remotes at the communication level: Catalog emits `cart:add` with a payload, the shell listens and updates its own cart store. The event contract (event name + payload type) is versioned in a shared npm package both teams depend on — but neither team depends on the other's implementation. Adding a new event type requires only updating the shared contract package.

**Q4. How do you handle TypeScript type safety across Module Federation remotes?**

Module Federation remotes are dynamically loaded at runtime — TypeScript can't inspect them at build time. You must manually declare the module types in `.d.ts` files: `declare module "catalog/ProductPage" { ... }`. The standard approach for a shared-types package: the catalog team publishes a `@acme/catalog-types` npm package with the TypeScript declarations for their exposed modules. The shell installs this package and TypeScript resolves remote imports through it. This creates a versioned type contract between teams — a breaking prop change to `ProductPage` becomes a major version bump in the types package, signaling to the shell team that an update is needed.

**Q5. What is a platform contract for micro-frontends and why is it necessary?**

A platform contract is a shared document (or enforced configuration) specifying the allowed version ranges for shared singleton dependencies — React, React Router, the design system, etc. Without it, Team A might upgrade React from 18 to 19, the shell loads React 19 as the singleton, and Team B's remote (still built against React 18 APIs) breaks silently or with cryptic errors. The contract defines: current singleton versions, the process for major version upgrades (RFC → team sign-off → coordinated upgrade window), and what `requiredVersion` the shared config must specify in each remote. Module Federation can enforce it at runtime with `strictVersion: true`, which throws rather than silently mismatching.

**Q6. How would you design integration testing for a micro-frontend architecture?**

Each team's CI tests their remote in isolation (unit tests, component tests, E2E against their own deployment). The gap: cross-team integration. An integration testing environment assembles all current production remotes in the shell (using their latest deployed `remoteEntry.js` URLs, not local builds). A nightly CI pipeline runs E2E tests against this assembled environment — testing user journeys that cross team boundaries (add a catalog item → navigate to checkout → complete order). When Team A deploys a breaking change to an exposed component's props, the integration tests catch it before it affects real users. Smoke tests on every remote deploy trigger the integration suite as well — so a remote deployment that breaks integration is detected within minutes, not after users report it.
