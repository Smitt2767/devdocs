---
title: Web Workers vs Service Workers
description: A practical breakdown of the differences between Web Workers and Service Workers, when to use each, and how to implement them in modern web apps.
---

## Overview

Both Web Workers and Service Workers let you run JavaScript off the main thread — but they solve completely different problems.

**Web Workers** give you a background thread for heavy computation. They keep your UI responsive by offloading CPU-intensive work (like parsing large datasets or running algorithms) away from the main thread.

**Service Workers** act as a programmable network proxy between your app and the internet. They intercept fetch requests, manage caching, enable offline support, and power push notifications.

| Feature                     | Web Worker | Service Worker    |
| --------------------------- | ---------- | ----------------- |
| Runs off main thread        | ✅         | ✅                |
| Access to DOM               | ❌         | ❌                |
| Intercepts network requests | ❌         | ✅                |
| Lifecycle tied to page      | ✅         | ❌ (persists)     |
| Use case                    | CPU tasks  | Caching / offline |

<Callout type="info">
  Neither worker type can directly access or manipulate the DOM. Communication
  with the main thread happens via `postMessage`.
</Callout>

---

## How It Works

### Web Workers

When you create a `Worker`, the browser spins up a separate JS thread. The worker runs in total isolation — no `window`, no `document`, no shared memory by default. You communicate using `postMessage` and `onmessage` events, passing data that is **structured-cloned** (deep copied) between threads.

For true shared memory, you can pass a `SharedArrayBuffer` along with `Atomics` for synchronization — but this requires specific HTTP headers (`Cross-Origin-Opener-Policy` and `Cross-Origin-Embedder-Policy`).

### Service Workers

A Service Worker is registered once per origin and persists independently of any single page. It has its own lifecycle:

1. **Install** — fires when the SW is first registered; ideal for pre-caching assets.
2. **Activate** — fires after install; used to clean up old caches.
3. **Fetch** — fires on every network request from controlled pages; this is where you implement caching strategies.

The browser controls when a Service Worker wakes up and goes idle. You cannot rely on it being continuously running.

<Callout type="warn">
  Service Workers only work on `https://` origins (or `localhost` for
  development). They will silently fail to register on plain HTTP.
</Callout>

---

## Code Examples

### Web Worker — Offloading Heavy Computation

**`worker.ts`** (the worker file)

```ts
// This file runs in a separate thread — no DOM access here
self.onmessage = (event: MessageEvent<number[]>) => {
  const numbers = event.data;

  // Simulate expensive computation: find all primes in the array
  const primes = numbers.filter((n) => {
    if (n < 2) return false;
    for (let i = 2; i <= Math.sqrt(n); i++) {
      if (n % i === 0) return false;
    }
    return true;
  });

  // Send result back to the main thread
  self.postMessage(primes);
};
```

**`app/page.tsx`** (Next.js App Router, Client Component — workers require browser APIs)

```tsx
"use client";

import { useEffect, useState } from "react";

export default function PrimeCalculator() {
  const [primes, setPrimes] = useState<number[]>([]);
  const [isCalculating, setIsCalculating] = useState(false);

  const runWorker = () => {
    setIsCalculating(true);

    // Instantiate the worker — Webpack/Turbopack handles the bundling
    const worker = new Worker(new URL("./worker.ts", import.meta.url));

    // Generate 10,000 random numbers to test
    const numbers = Array.from({ length: 10_000 }, () =>
      Math.floor(Math.random() * 100_000),
    );

    worker.postMessage(numbers);

    worker.onmessage = (event: MessageEvent<number[]>) => {
      setPrimes(event.data);
      setIsCalculating(false);
      worker.terminate(); // Always terminate when done to free resources
    };

    worker.onerror = (err) => {
      console.error("Worker error:", err);
      setIsCalculating(false);
      worker.terminate();
    };
  };

  return (
    <div>
      <button onClick={runWorker} disabled={isCalculating}>
        {isCalculating ? "Calculating..." : "Find Primes"}
      </button>
      <p>Found {primes.length} prime numbers</p>
    </div>
  );
}
```

---

### Service Worker — Cache-First Strategy for Static Assets

**`public/sw.js`**

```js
const CACHE_NAME = "app-cache-v1";

// Assets to pre-cache during install
const PRECACHE_URLS = ["/", "/about", "/offline.html"];

self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => cache.addAll(PRECACHE_URLS)),
  );
  // Activate immediately without waiting for old SW to become idle
  self.skipWaiting();
});

self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) =>
      Promise.all(
        cacheNames
          // Delete caches from old versions
          .filter((name) => name !== CACHE_NAME)
          .map((name) => caches.delete(name)),
      ),
    ),
  );
  self.clients.claim();
});

self.addEventListener("fetch", (event) => {
  // Only handle GET requests — skip POST, PUT, etc.
  if (event.request.method !== "GET") return;

  event.respondWith(
    caches.match(event.request).then((cachedResponse) => {
      // Return from cache if available, otherwise fetch from network
      return (
        cachedResponse ??
        fetch(event.request).catch(() =>
          // If both cache and network fail, serve the offline fallback
          caches.match("/offline.html"),
        )
      );
    }),
  );
});
```

**Registering the Service Worker in Next.js App Router**

```tsx
// app/layout.tsx
"use client";

import { useEffect } from "react";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  useEffect(() => {
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker
        .register("/sw.js")
        .then((reg) => console.log("SW registered:", reg.scope))
        .catch((err) => console.error("SW registration failed:", err));
    }
  }, []);

  return (
    <html lang="en">
      <body>{children}</body>
    </html>
  );
}
```

<Callout type="info">
  Place `sw.js` inside the `public/` directory so Next.js serves it at the root
  scope (`/sw.js`). A Service Worker can only control pages within its scope,
  which is determined by where the SW file is served from.
</Callout>

---

## Real-World Use Cases

**Web Worker:**
A data visualization dashboard receives a JSON payload with 500,000 rows from an API. Parsing, filtering, and aggregating that data on the main thread would freeze the UI for seconds. Offloading the transformation to a Web Worker keeps the page interactive while the computation runs in the background.

**Service Worker:**
An e-commerce PWA needs to work reliably on flaky mobile connections. A Service Worker pre-caches the product listing pages and shells on install, intercepts all API calls, and serves stale data with a background revalidation strategy. Users can browse the catalog even when fully offline.

---

## Common Mistakes / Gotchas

**1. Trying to access the DOM inside a worker**
Both worker types run outside the main thread and have no access to `document`, `window`, or any DOM APIs. If you need to update the UI based on worker results, post a message back and handle it in your component.

**2. Forgetting to terminate Web Workers**
Web Workers don't clean themselves up. Always call `worker.terminate()` when the work is done, or when the component unmounts — otherwise you'll leak threads across navigations.

```tsx
useEffect(() => {
  const worker = new Worker(new URL("./worker.ts", import.meta.url));
  // ... setup

  return () => worker.terminate(); // Cleanup on unmount
}, []);
```

**3. Assuming the Service Worker intercepts requests immediately**
A freshly registered Service Worker only takes control of pages after they are reloaded. The current page load is not controlled. Use `self.skipWaiting()` + `clients.claim()` during activation to gain control immediately (shown in the example above).

**4. Confusing the two when the solution seems ambiguous**
If your problem is _slow JS execution_, use a **Web Worker**. If your problem is _slow or unreliable networking / offline support_, use a **Service Worker**. They are not interchangeable.

**5. Mutating `SharedArrayBuffer` without `Atomics`**
If you use `SharedArrayBuffer` for shared memory between a Web Worker and the main thread, you must use `Atomics` methods for reads and writes. Race conditions are real — uncoordinated access leads to data corruption.

---

## Summary

Web Workers and Service Workers both run JavaScript off the main thread, but serve entirely different purposes. Use a Web Worker when you need to run expensive computations without blocking the UI. Use a Service Worker when you need to control network behavior — caching, offline support, or background sync. Neither can touch the DOM; both communicate via `postMessage`. Always terminate Web Workers when finished to avoid memory leaks, and remember that Service Workers have a registration-then-activation lifecycle that means they don't control the current page load by default.
