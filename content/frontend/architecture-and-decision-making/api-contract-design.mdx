---
title: API Contract Design
description: How to define, enforce, and maintain reliable API contracts between frontend and backend to eliminate integration bugs and enable parallel development.
---

## Overview

An API contract is a formal agreement between a frontend and backend about how they communicate — what endpoints exist, what data shapes are sent and received, what errors look like, and what authentication is required.

Without a contract, frontend and backend teams make assumptions about each other. Those assumptions drift. You get runtime errors in production, broken UIs, and debugging sessions that waste hours tracing a mismatched field name.

A well-designed contract lets both sides develop in parallel, generates types automatically, and makes breaking changes visible before they ship.

## How It Works

Think of an API contract like a legal document between two services. Both sides sign it. If one side changes the agreement, the other side gets notified — or the build fails.

In practice, contracts are expressed as a schema (OpenAPI, GraphQL SDL, tRPC router, or Zod schema). From that schema:

- The backend validates incoming requests and outgoing responses against it.
- The frontend gets generated TypeScript types so it never has to guess the shape of a response.
- Both sides can be tested in isolation using mocks derived from the contract.

The three most common approaches in modern TypeScript stacks are:

**1. OpenAPI (REST)** — Write or generate a YAML/JSON spec. Use codegen to produce types for both sides.

**2. tRPC** — Define procedures in TypeScript on the server. The client infers types directly from the router. No codegen step needed.

**3. GraphQL** — Define a schema with SDL. Generate types for both client and server from that single source of truth.

## Code Examples

### Approach 1: tRPC with Next.js App Router

tRPC is the tightest frontend-backend contract possible in a TypeScript monorepo. The server router _is_ the contract.

```bash
npm install @trpc/server @trpc/client @trpc/react-query @tanstack/react-query zod
```

**`src/server/trpc.ts`** — Initialize tRPC:

```ts
import { initTRPC } from "@trpc/server";
import { z } from "zod";

const t = initTRPC.create();

export const router = t.router;
export const publicProcedure = t.procedure;
```

**`src/server/routers/orders.ts`** — Define the contract:

```ts
import { z } from "zod";
import { router, publicProcedure } from "../trpc";
import { db } from "@/lib/db";

// This Zod schema IS the contract for what a caller must send.
const createOrderSchema = z.object({
  productId: z.string().uuid(),
  quantity: z.number().int().min(1).max(100),
  shippingAddress: z.object({
    street: z.string().min(1),
    city: z.string().min(1),
    postalCode: z.string().regex(/^\d{5}$/),
  }),
});

export const ordersRouter = router({
  create: publicProcedure
    .input(createOrderSchema)
    .mutation(async ({ input }) => {
      // input is fully typed — no casting needed
      const order = await db.order.create({
        data: {
          productId: input.productId,
          quantity: input.quantity,
          street: input.shippingAddress.street,
          city: input.shippingAddress.city,
          postalCode: input.shippingAddress.postalCode,
        },
      });
      return { orderId: order.id, status: "created" as const };
    }),

  list: publicProcedure
    .input(z.object({ page: z.number().int().min(1).default(1) }))
    .query(async ({ input }) => {
      const orders = await db.order.findMany({
        skip: (input.page - 1) * 20,
        take: 20,
        orderBy: { createdAt: "desc" },
      });
      return orders;
    }),
});
```

**`src/server/root.ts`** — Merge routers:

```ts
import { router } from "./trpc";
import { ordersRouter } from "./routers/orders";

export const appRouter = router({
  orders: ordersRouter,
});

// Export the type — this is what the client imports for full type inference
export type AppRouter = typeof appRouter;
```

**`src/app/api/trpc/[trpc]/route.ts`** — Expose via Next.js App Router:

```ts
import { fetchRequestHandler } from "@trpc/server/adapters/fetch";
import { appRouter } from "@/server/root";

const handler = (req: Request) =>
  fetchRequestHandler({
    endpoint: "/api/trpc",
    req,
    router: appRouter,
    createContext: () => ({}),
  });

export { handler as GET, handler as POST };
```

**`src/lib/trpc-client.ts`** — Client setup:

```ts
import { createTRPCReact } from "@trpc/react-query";
import type { AppRouter } from "@/server/root";

// AppRouter type flows from server to client — no manual type duplication
export const trpc = createTRPCReact<AppRouter>();
```

**`src/app/orders/page.tsx`** — Server Component calling tRPC directly:

```tsx
import { appRouter } from "@/server/root";

export default async function OrdersPage() {
  // Call the procedure directly on the server — no HTTP round trip
  const caller = appRouter.createCaller({});
  const orders = await caller.orders.list({ page: 1 });

  return (
    <ul>
      {orders.map((order) => (
        <li key={order.id}>
          Order {order.id} — {order.quantity} items
        </li>
      ))}
    </ul>
  );
}
```

<Callout type="info">
  In Server Components, call tRPC procedures directly via `createCaller`. Only
  use the HTTP client (`trpc.orders.list.useQuery()`) inside Client Components
  that need reactivity.
</Callout>

---

### Approach 2: OpenAPI with Zod + next-zod-openapi

Use this when you need to expose a public API or work with non-TypeScript consumers.

**`src/lib/openapi.ts`** — Define a shared response schema:

```ts
import { z } from "zod";

// Define once, reuse on both sides
export const ProductSchema = z.object({
  id: z.string().uuid(),
  name: z.string(),
  priceInCents: z.number().int().positive(),
  inStock: z.boolean(),
});

export const ProductListResponseSchema = z.object({
  data: z.array(ProductSchema),
  total: z.number().int(),
  page: z.number().int(),
});

// Export the inferred type for use in frontend code
export type ProductListResponse = z.infer<typeof ProductListResponseSchema>;
```

**`src/app/api/products/route.ts`** — Validate the response before sending:

```ts
import { NextResponse } from "next/server";
import { ProductListResponseSchema } from "@/lib/openapi";
import { db } from "@/lib/db";

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const page = Number(searchParams.get("page") ?? "1");

  const [products, total] = await Promise.all([
    db.product.findMany({ skip: (page - 1) * 20, take: 20 }),
    db.product.count(),
  ]);

  // Parse validates the shape — throws if the DB model drifts from the contract
  const response = ProductListResponseSchema.parse({
    data: products,
    total,
    page,
  });

  return NextResponse.json(response);
}
```

**`src/hooks/use-products.ts`** — Frontend consumes the same type:

```ts
"use client";

import { useEffect, useState } from "react";
import type { ProductListResponse } from "@/lib/openapi";

export function useProducts(page: number) {
  const [data, setData] = useState<ProductListResponse | null>(null);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetch(`/api/products?page=${page}`)
      .then((res) => {
        if (!res.ok) throw new Error(`Request failed: ${res.status}`);
        return res.json() as Promise<ProductListResponse>;
      })
      .then(setData)
      .catch((err: Error) => setError(err.message));
  }, [page]);

  return { data, error };
}
```

<Callout type="warn">
  Casting with `as Promise<ProductListResponse>` trusts the server. For production, parse the response with Zod on the client too — especially if the API is consumed by external parties.
</Callout>

---

### Standardized Error Shape

Your contract must include errors, not just success responses. Define a consistent error envelope:

```ts
// src/lib/api-error.ts

export type ApiError = {
  code: "NOT_FOUND" | "UNAUTHORIZED" | "VALIDATION_ERROR" | "INTERNAL_ERROR";
  message: string;
  // Optional structured details for validation errors
  details?: Record<string, string[]>;
};

export function createApiError(
  code: ApiError["code"],
  message: string,
  details?: ApiError["details"],
): Response {
  const body: ApiError = { code, message, ...(details ? { details } : {}) };
  const statusMap: Record<ApiError["code"], number> = {
    NOT_FOUND: 404,
    UNAUTHORIZED: 401,
    VALIDATION_ERROR: 422,
    INTERNAL_ERROR: 500,
  };
  return Response.json(body, { status: statusMap[code] });
}
```

```ts
// Usage in a route handler
import { createApiError } from "@/lib/api-error";

export async function GET(
  _req: Request,
  { params }: { params: { id: string } },
) {
  const product = await db.product.findUnique({ where: { id: params.id } });

  if (!product) {
    return createApiError("NOT_FOUND", `Product ${params.id} does not exist`);
  }

  return Response.json(product);
}
```

## Real-World Use Case

You're building a B2B SaaS app. The frontend team starts building the order management UI on Monday. The backend team is still writing the database migrations.

With a contract-first approach:

1. Both teams agree on the `OrderSchema` using Zod on day one and commit it to `src/lib/schemas/order.ts`.
2. The frontend generates mock data from the schema using a tool like `@faker-js/faker` constrained to the schema shape.
3. The backend validates every response against the schema before it ships.
4. When the backend changes `totalAmount` to `totalAmountInCents`, the TypeScript compiler immediately flags every frontend callsite. The bug never reaches staging.

This pattern eliminates the most common source of frontend-backend bugs: mismatched field names and unexpected nulls.

## Common Mistakes / Gotchas

**1. Treating the schema as backend-only**

A common mistake is defining validation schemas only in the backend route handler and manually duplicating types on the frontend. When the backend changes, the frontend types silently go stale. Always share schemas from a single source — either a shared `lib/schemas` module, tRPC's inferred types, or codegen output.

**2. Not versioning breaking changes**

Renaming a field, changing a type from `string` to `number`, or removing a field are all breaking changes. If your API is consumed by anything other than your own frontend, those changes need a version bump (`/api/v2/...`) or a migration period. Even internally, coordinate breaking changes explicitly with a deprecation comment and a removal date.

**3. Ignoring error contracts**

Most teams define success response shapes carefully and leave errors as ad-hoc strings. The frontend then has a mess of `catch (e: any)` blocks and inconsistent error UI. Define your error envelope once, share the type, and handle it consistently. tRPC does this automatically via `TRPCError`. For REST, define it yourself as shown above.

**4. Skipping response validation on the backend**

Writing a Zod schema and only using it to generate TypeScript types (without `.parse()` at runtime) means your DB model can drift from your contract without any warning. Validate outgoing responses in development at minimum. In production, log schema violations rather than throwing — but validate.

**5. Over-fetching by default**

Designing REST endpoints that return entire database records because "the frontend might need it someday" leaks sensitive fields and wastes bandwidth. Design responses around what the UI actually needs. Use tRPC's `.select()` or explicit response schemas to enforce this.

## Summary

An API contract is the explicit, enforced agreement between frontend and backend about data shapes, endpoints, and error formats. Without it, integration bugs accumulate silently. In a TypeScript stack, tRPC is the most ergonomic approach — the router type flows directly to the client with no codegen. For public or polyglot APIs, shared Zod schemas with OpenAPI generation are the standard. Regardless of approach, always share types from a single source, define your error shape as rigorously as your success shape, and validate responses at runtime — not just at compile time.
