---
title: Pointer Events
description: How the Pointer Events API unifies mouse, touch, and stylus input — pointerId multi-touch tracking, setPointerCapture for drag reliability, touch-action CSS, pointercancel handling, hardware metadata (pressure, tiltX, tiltY), and the accessibility implications of touch-only patterns.
---

## Overview

Before the Pointer Events API, web developers maintained separate `mousedown`/`mousemove` and `touchstart`/`touchmove` handlers for every interactive element — duplicating logic and producing subtle behavioural differences across device types. The Pointer Events API unifies all input devices — mouse, touch, and stylus (pen) — into a single consistent event model.

Every contact point (a finger, mouse cursor, or pen tip) gets a unique `pointerId`. Events fire in a consistent sequence regardless of input type. Hardware metadata like `pressure`, `tiltX`, and `tiltY` is available when the device supports it.

---

## How It Works

### Event Sequence

Every pointer interaction follows this lifecycle:

```
pointerdown  →  pointermove  →  pointerup
                                pointercancel  (browser takeover — handle this)
```

| Event                           | When it fires                                                 |
| ------------------------------- | ------------------------------------------------------------- |
| `pointerdown`                   | Contact begins (mouse button down, finger touch, pen contact) |
| `pointermove`                   | Pointer moves while in contact or hovering                    |
| `pointerup`                     | Contact ends cleanly                                          |
| `pointercancel`                 | Browser takes control (system gesture, scroll, screen lock)   |
| `pointerenter` / `pointerleave` | Pointer enters/leaves element boundary (doesn't bubble)       |
| `pointerover` / `pointerout`    | Like mouseenter/mouseleave but bubbles                        |

### Key Properties

| Property              | Type                          | Description                                                           |
| --------------------- | ----------------------------- | --------------------------------------------------------------------- |
| `pointerId`           | `number`                      | Unique ID for each contact point (finger, pen, mouse cursor)          |
| `pointerType`         | `"mouse" \| "touch" \| "pen"` | Input device type                                                     |
| `isPrimary`           | `boolean`                     | True for the first contact in a multi-touch sequence                  |
| `pressure`            | `number`                      | 0–1; 0 = no contact, 0.5 = mouse button held, 1 = max pen pressure    |
| `tiltX` / `tiltY`     | `number`                      | Pen tilt angle in degrees (−90 to 90)                                 |
| `width` / `height`    | `number`                      | Contact area size in CSS pixels (finger pads are wider than pen tips) |
| `clientX` / `clientY` | `number`                      | Position relative to viewport                                         |

### Pointer Capture

`setPointerCapture(pointerId)` routes all subsequent events for that pointer to the capturing element — regardless of where the pointer physically moves. Critical for drag interactions: without capture, `pointermove` stops firing the moment the pointer leaves the element's bounding box.

### `touch-action` CSS

The browser intercepts touch events for its own pan/zoom gestures before firing `pointermove`. Setting `touch-action: none` on an element tells the browser to skip its own gesture handling and pass all touch events to the page's JavaScript. Without it, the browser may scroll instead of firing your `pointermove`, or fire `pointercancel` mid-gesture.

---

## Code Examples

### 1. Universal Drag Interaction

```tsx
// components/DraggableCard.tsx
"use client";
import { useRef } from "react";

export function DraggableCard({ children }: { children: React.ReactNode }) {
  const cardRef = useRef<HTMLDivElement>(null);
  const drag = useRef({
    active: false,
    startX: 0,
    startY: 0,
    origX: 0,
    origY: 0,
  });

  function onPointerDown(e: React.PointerEvent<HTMLDivElement>) {
    e.preventDefault();
    // Capture the pointer — ensures pointermove fires even outside the element
    e.currentTarget.setPointerCapture(e.pointerId);

    const rect = cardRef.current!.getBoundingClientRect();
    drag.current = {
      active: true,
      startX: e.clientX,
      startY: e.clientY,
      origX: rect.left,
      origY: rect.top,
    };
  }

  function onPointerMove(e: React.PointerEvent<HTMLDivElement>) {
    if (!drag.current.active) return;

    const dx = e.clientX - drag.current.startX;
    const dy = e.clientY - drag.current.startY;

    cardRef.current!.style.transform = `translate(${dx}px, ${dy}px)`;
  }

  function onPointerUp(e: React.PointerEvent<HTMLDivElement>) {
    drag.current.active = false;
    // Capture releases automatically on pointerup, but explicit is clearer
    e.currentTarget.releasePointerCapture(e.pointerId);
  }

  // pointercancel fires when the browser takes over (system gesture, scroll, etc.)
  // Treat it identically to pointerup — reset state
  function onPointerCancel(e: React.PointerEvent<HTMLDivElement>) {
    drag.current.active = false;
    cardRef.current!.style.transform = "";
  }

  return (
    <div
      ref={cardRef}
      onPointerDown={onPointerDown}
      onPointerMove={onPointerMove}
      onPointerUp={onPointerUp}
      onPointerCancel={onPointerCancel}
      style={{
        touchAction: "none", // prevent browser scroll/zoom during drag
        cursor: "grab",
        userSelect: "none",
        display: "inline-block",
        padding: "1rem",
        border: "1px solid #ccc",
        borderRadius: "8px",
      }}
    >
      {children}
    </div>
  );
}
```

---

### 2. Multi-Touch Tracking with `pointerId`

```tsx
// components/Canvas.tsx
"use client";
import { useRef } from "react";

interface ActivePoint {
  x: number;
  y: number;
  prevX: number;
  prevY: number;
}

export function DrawingCanvas() {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  // Map from pointerId → active stroke data
  // Keying by pointerId is essential — each finger is a separate contact
  const points = useRef(new Map<number, ActivePoint>());

  function getCtx() {
    return canvasRef.current?.getContext("2d");
  }

  function onPointerDown(e: React.PointerEvent<HTMLCanvasElement>) {
    e.currentTarget.setPointerCapture(e.pointerId);
    points.current.set(e.pointerId, {
      x: e.clientX,
      y: e.clientY,
      prevX: e.clientX,
      prevY: e.clientY,
    });
  }

  function onPointerMove(e: React.PointerEvent<HTMLCanvasElement>) {
    const point = points.current.get(e.pointerId);
    if (!point) return;

    const ctx = getCtx();
    if (!ctx) return;

    ctx.beginPath();
    ctx.moveTo(point.prevX, point.prevY);
    ctx.lineTo(e.clientX, e.clientY);

    // Scale line width by pressure — works for stylus, approximated for touch
    // Mouse always reports pressure=0.5 when button held, so ignore for mouse
    ctx.lineWidth =
      e.pointerType === "pen"
        ? Math.max(1, e.pressure * 10) // pen pressure is meaningful
        : 2; // fixed width for mouse and touch

    ctx.strokeStyle = e.pointerType === "pen" ? "#1e293b" : "#3b82f6";
    ctx.stroke();

    // Update previous position
    points.current.set(e.pointerId, {
      x: e.clientX,
      y: e.clientY,
      prevX: e.clientX,
      prevY: e.clientY,
    });
  }

  function onPointerUp(e: React.PointerEvent<HTMLCanvasElement>) {
    points.current.delete(e.pointerId);
  }

  // pointercancel — browser took over, clean up this pointer's state
  function onPointerCancel(e: React.PointerEvent<HTMLCanvasElement>) {
    points.current.delete(e.pointerId);
  }

  return (
    <canvas
      ref={canvasRef}
      width={800}
      height={600}
      onPointerDown={onPointerDown}
      onPointerMove={onPointerMove}
      onPointerUp={onPointerUp}
      onPointerCancel={onPointerCancel}
      style={{ touchAction: "none", border: "1px solid #e2e8f0" }}
    />
  );
}
```

---

### 3. Pressure and Tilt (Stylus)

```tsx
// components/StylusInfo.tsx
"use client";
import { useState } from "react";

interface StylusStats {
  pressure: number;
  tiltX: number;
  tiltY: number;
  pointerType: string;
}

export function StylusInfo() {
  const [stats, setStats] = useState<StylusStats | null>(null);

  function onPointerMove(e: React.PointerEvent<HTMLDivElement>) {
    setStats({
      pressure: e.pressure,
      tiltX: e.tiltX, // degrees from vertical in the X plane (−90 to 90)
      tiltY: e.tiltY, // degrees from vertical in the Y plane (−90 to 90)
      pointerType: e.pointerType,
    });
  }

  return (
    <div
      onPointerMove={onPointerMove}
      style={{ touchAction: "none", padding: "2rem", border: "1px solid #ccc" }}
    >
      {stats ? (
        <pre>{JSON.stringify(stats, null, 2)}</pre>
      ) : (
        <p>Move a pointer (pen/touch/mouse) over this area</p>
      )}
    </div>
  );
}
```

---

### 4. Accessibility — Ensuring Touch-Only Interactions Have Keyboard Alternatives

Touch-only interactions (swipe to delete, long-press for context, custom drag) are inaccessible to keyboard users and users of switch devices. Always provide a keyboard alternative:

```tsx
// components/SwipeableListItem.tsx
"use client";

interface ListItemProps {
  label: string;
  onDelete: () => void;
}

export function SwipeableListItem({ label, onDelete }: ListItemProps) {
  // Swipe gesture for touch users
  let startX = 0;

  function onPointerDown(e: React.PointerEvent) {
    startX = e.clientX;
    e.currentTarget.setPointerCapture(e.pointerId);
  }

  function onPointerUp(e: React.PointerEvent) {
    const delta = e.clientX - startX;
    if (delta < -80) onDelete(); // swipe left by 80px → delete
  }

  return (
    <div
      style={{ display: "flex", alignItems: "center", gap: "1rem" }}
      onPointerDown={onPointerDown}
      onPointerUp={onPointerUp}
    >
      <span>{label}</span>

      {/*
       * ✅ Keyboard-accessible delete button alongside the swipe gesture.
       * Touch users can swipe; keyboard/AT users use this button.
       * Never rely solely on gesture interactions.
       */}
      <button type="button" onClick={onDelete} aria-label={`Delete ${label}`}>
        Delete
      </button>
    </div>
  );
}
```

<Callout type="warn">
  WCAG 2.1 SC 2.5.1 (Pointer Gestures) requires that all functionality using
  multi-point or path-based gestures (swipe, pinch, drag) also be operable with
  a single pointer via an alternative mechanism. Touch-only interactions without
  keyboard equivalents are a WCAG failure.
</Callout>

---

## Real-World Use Cases

**Signature pad** — Legal or fintech apps need signatures on tablets. `pointerdown`/`pointermove` with `setPointerCapture` and pen `pressure` produces smooth, realistic signatures that work equally well with finger, mouse, or stylus.

**Whiteboard** — A collaborative canvas needs simultaneous multi-touch (two-finger zoom, multiple users drawing). The `pointerId` system tracks each contact independently without index juggling.

**Custom drag-and-drop** — When the native HTML DnD API is too constrained (no touch support, limited visual control), Pointer Events gives consistent cross-device drag without a library dependency.

---

## Common Mistakes / Gotchas

**1. Forgetting `touch-action: none`.** Without it, the browser's pan/zoom gesture handling fires before your `pointermove` or fires `pointercancel` mid-drag. Always set `touch-action: none` on elements that manage their own pointer input.

**2. Not calling `setPointerCapture` for drag interactions.** Without capture, `pointermove` stops firing when the pointer leaves the element boundary. Fast drags silently "drop" the element. Always call `e.currentTarget.setPointerCapture(e.pointerId)` in `pointerdown`.

**3. Treating all pointers as primary.** When multiple fingers are on screen, only the first contact is `isPrimary === true`. Using `e.clientX` unconditionally without keying by `pointerId` corrupts state when two fingers interact simultaneously. Always use a `Map<number, ...>` keyed by `pointerId`.

**4. Assuming `pressure` is meaningful for mice.** A mouse always reports `pressure = 0.5` when a button is held and `0` otherwise — it has no pressure sensor. Only genuine pen and some touch hardware provides meaningful pressure values. Gate pressure-sensitive behaviour on `e.pointerType === "pen"`.

**5. Ignoring `pointercancel`.** The browser fires `pointercancel` when a system gesture (back swipe, screen lock, notification) interrupts the interaction. If you only handle `pointerup`, leaked state (active drag positions, open contact IDs in your Map) accumulates. Always handle `pointercancel` identically to `pointerup`.

---

## Summary

The Pointer Events API unifies mouse, touch, and stylus input into a single event model — eliminating separate `mouse*` and `touch*` handlers. Each contact gets a unique `pointerId` for independent multi-touch tracking, and hardware metadata like `pressure` and `tiltX/tiltY` is available when supported. `setPointerCapture` is essential for drag and drawing interactions to keep events firing outside element boundaries. Always set `touch-action: none` to prevent browser gesture interception. Handle `pointercancel` identically to `pointerup` to avoid leaked state. For accessibility: any touch gesture interaction must have a keyboard-accessible alternative per WCAG 2.1 SC 2.5.1.

---

## Interview Questions

**Q1. What problem does the Pointer Events API solve, and how does it unify input handling?**

Before Pointer Events, developers maintained duplicate event handler sets: `mousedown`/`mousemove`/`mouseup` for mouse users and `touchstart`/`touchmove`/`touchend` for touch users. These APIs have different shapes (touch events have a `touches` array; mouse events have single coordinates), different default browser behaviours, and different platform quirks. The Pointer Events API maps all input devices — mouse, capacitive touch, resistive touch, stylus/pen, and eye-tracking pointers — onto a single event type with a consistent property shape. `pointerdown`, `pointermove`, `pointerup`, and `pointercancel` fire for all device types. Device-specific information (pressure, tilt, contact size) is available via standard properties, and `pointerType` lets you branch on device type when needed. One set of handlers covers all input devices.

**Q2. What is `setPointerCapture` and why is it critical for drag interactions?**

`setPointerCapture(pointerId)` routes all subsequent events for the captured pointer to the element that called it, regardless of where the pointer physically moves on screen. Without capture: when a user drags an element and their pointer exits the element's bounding box (which happens instantly with fast mouse movements), the browser stops delivering `pointermove` and `pointerup` events to that element — the drag silently breaks. With capture: all events continue routing to the capturing element until `pointerup`, `pointercancel`, or explicit `releasePointerCapture` is called. Call `setPointerCapture(e.pointerId)` in `pointerdown`. Pointer capture releases automatically when the pointer is lifted, so `releasePointerCapture` is rarely needed explicitly.

**Q3. What is `touch-action` and what happens if you forget to set it?**

`touch-action` is a CSS property that tells the browser which touch gestures it should handle natively (pan, pinch-zoom) versus pass to the page's JavaScript. The default is `auto` — the browser handles its own gestures and may intercept touch input before your pointer event handlers fire. On a vertically scrollable page, a downward touch drag fires the browser's scroll behaviour rather than triggering `pointermove`. Worse: once the browser decides to scroll, it fires `pointercancel` on your element, cancelling any in-progress interaction. Setting `touch-action: none` disables all browser gesture handling on the element, ensuring all touch events flow to your handlers. `touch-action: pan-x` allows horizontal scrolling but not vertical; `touch-action: pan-y` does the opposite — useful when you want to intercept only one axis.

**Q4. Why must you handle `pointercancel` and what triggers it?**

`pointercancel` fires when the browser forcibly ends a pointer interaction — it does not fire if the user lifts their finger cleanly (that's `pointerup`). Common triggers: a system gesture interrupts (iOS back swipe, Android task switcher swipe, screen lock), the browser decides to scroll or zoom instead of passing events to the page (especially without `touch-action: none`), a touch contact is lost due to too many simultaneous touches, or the device orientation changes mid-interaction. If you only handle `pointerup`, `pointercancel` leaves your interaction in a broken state: the drag position is still "active" in your state, the captured pointer is released by the browser but your Map still has an entry, and the element may be visually stuck in its dragged position. Handle `pointercancel` identically to `pointerup`: release state, clear the `pointerId` from your Map, reset any in-progress visual changes.

**Q5. What is the WCAG requirement for gesture-based interactions, and how do you satisfy it?**

WCAG 2.1 Success Criterion 2.5.1 (Pointer Gestures, Level A) requires that all functionality that uses multi-point gestures (pinch-zoom, two-finger swipe) or path-based gestures (swipe to delete, drag to reorder) can also be operated with a single pointer via an alternative mechanism. "Single pointer" means a single tap, click, or simple drag — it does not require keyboard access specifically, but in practice the alternative is usually a button. For a swipe-to-delete list item: provide a "Delete" button alongside the swipe gesture. For pinch-to-zoom: provide + and − buttons. For drag-to-reorder: provide up/down arrow buttons or a handle with keyboard support. The gesture is not forbidden — the alternative is required. Additionally, SC 2.5.4 (Motion Actuation) requires that any function activated by device motion (shake to undo) also be available via a conventional UI control.

**Q6. Why does a mouse always report `pressure = 0.5` and how should you handle pressure data for multi-device scenarios?**

The `pressure` property in `PointerEvent` represents the normalised pressure (0–1) of the contact. For genuine pressure-sensitive hardware (stylus/pen, some touchscreens), this value varies continuously based on how hard the user presses. For a mouse, there is no pressure sensor — the spec defines that `pressure` is `0.5` when any mouse button is depressed and `0` when no button is pressed. This is a static value, not a measurement. If you build pressure-sensitive drawing where line width scales with `pressure`, mouse users always get exactly `0.5 * maxWidth` — which may be acceptable but is not variable. Gate pressure-sensitive behaviour on `e.pointerType === "pen"`, provide a fixed line width for `"mouse"` and `"touch"`, and document what hardware your feature requires. `tiltX` and `tiltY` similarly return `0` for non-pen devices — gate tilt-based brush angle on `e.pointerType === "pen"`.
